<!DOCTYPE HTML>
<html lang="null">
<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="五年C++程序员的口水博客">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="https://israel-liu.github.io">
    <!--SEO-->





<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->


<title>C++ Primer, Fifth Edition reading_note_one | 五年C++程序员的口水博客</title>


    <link rel="alternate" href="/atom.xml" title="五年C++程序员的口水博客" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    
</head>


<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(https://github.com/israel-Liu/theForger/raw/master/images/byosoku.jpg)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='Licca Chen'>
            <img src="/img/avatar.JPG" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                 <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
    	</div>
    </div>
</header>

    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="https://israel-liu.github.io">五年C++程序员的口水博客</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>Home</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>timeline</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/tags/"><i class="fa "></i>Tags</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/about/"><i class="fa "></i>About</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="C++ Primer, Fifth Edition reading_note_one">
            
	            C++ Primer, Fifth Edition reading_note_one
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/ ">
             
        </a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2016/12/01</span>
        </span>
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <p>总之先写点什么吧，对markdown的编辑格式还不是很熟悉<br>排版就先这样好了，日后再修改，或许发个markdown编辑格式的博文也不错，<br>分类什么的也比较乱，以后还是尽量写英文吧，从最短的地方补起来</p>
<h2 id="下面正文开始"><a href="#下面正文开始" class="headerlink" title="下面正文开始"></a>下面正文开始</h2><h3 id="Top-Level-const"><a href="#Top-Level-const" class="headerlink" title="Top-Level const"></a>Top-Level const</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;We user the term Top-Level const to indicate that the pointer itself<br>is a const. When a pointer can point to a const object, we refer to that<br>const as a low-level const.<br>&nbsp;&nbsp;&nbsp;&nbsp;The distinction between top-level and low-level matters when we copy<br>an object. When we copy an object, top-level consts are ignored.<br>&nbsp;&nbsp;&nbsp;&nbsp;简单的说指针和引用的基本类型部分（low-level const）当执行对象拷贝操作时，<br>常量可以拷贝给常量，非常量可以拷贝给常量（可以转换）反之不行。</p>
<h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p1 = &amp;i;       <span class="comment">// we can't change the value of p1; const is top-level</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;        <span class="comment">// we can't change ci; const is top-level</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p2 = &amp;ci;      <span class="comment">// we can change p2; const is low-level</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p3 = p2; <span class="comment">// right-most const is top-level, left-most is not</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; r = ci;        <span class="comment">// const in reference types is always low-level</span></span><br></pre></td></tr></table></figure>
<h3 id="Standard-Container-Iterator-Operations"><a href="#Standard-Container-Iterator-Operations" class="headerlink" title="Standard Container Iterator Operations"></a>Standard Container Iterator Operations</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;因为操作符重载和语言基本的(-&gt;)箭头操作，搞定我晕晕的，提一下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iter-&gt;mem;  <span class="comment">// Dereferences iter and fetches the member named mem from</span></span><br><span class="line">            <span class="comment">// the underlying element. Equivalent to (*iter).mem</span></span><br></pre></td></tr></table></figure></p>
<h2 id="文章结束之前提一下-begin-end"><a href="#文章结束之前提一下-begin-end" class="headerlink" title="文章结束之前提一下 begin(),  end()."></a>文章结束之前提一下 begin(),  end().</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;begin returns a pointer to the first, and end returns a pointer one past the last<br>element in the given array: These functions are defined in the iterator header<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;   <span class="comment">// ia is an array of ten ints</span></span><br><span class="line"><span class="keyword">int</span> *beg = begin(ia);               <span class="comment">// pointer to the first element in ia</span></span><br><span class="line"><span class="keyword">int</span> *last = end(ia);                <span class="comment">// pointer one past the last element in ia</span></span><br></pre></td></tr></table></figure></p>
<h2 id="End-第一篇到这里了，Note-还有个vector无符号下标，内置数组有符号下标"><a href="#End-第一篇到这里了，Note-还有个vector无符号下标，内置数组有符号下标" class="headerlink" title="End 第一篇到这里了，Note 还有个vector无符号下标，内置数组有符号下标"></a>End 第一篇到这里了，Note 还有个vector无符号下标，内置数组有符号下标</h2><h2 id="Chapter-1-Getting-Started"><a href="#Chapter-1-Getting-Started" class="headerlink" title="Chapter 1. Getting Started"></a>Chapter 1. Getting Started</h2><p>当用 CMD 窗口执行程序后，那么这个窗口应该就是这个程序所有了？输入输出流的返回值还是输入输出流，这样可以连续使用 operator &lt;&lt;. 语言本身不支持输入输出。通过使用库 I/O。<br>临时变量只要还在 stack 中就是有效的对吧？只用点操作符访问成员方法，所以加 () 操作符之前只是没有调用为啥是不合法的？reading cin flushes cout ？</p>
<h2 id="Part-I-The-Basics"><a href="#Part-I-The-Basics" class="headerlink" title="Part I: The Basics"></a>Part I: The Basics</h2><p>区分语言和库还是很重要的，要知道语言本身提供了什么东西，我们可以用来做什么，比如利用provides mechanisms that let us define our own data types.写库。</p>
<h2 id="Chapter-2-Variables-and-Basic-Types"><a href="#Chapter-2-Variables-and-Basic-Types" class="headerlink" title="Chapter 2. Variables and Basic Types"></a>Chapter 2. Variables and Basic Types</h2><p>The smallest chunk of addressable memory is referred to as a “byte.”  类型设计是要更好的接近硬件层。<br>类型char，可能是有符号的也可能是无符号的，不要再算数表达式里面使用，使用时候要明确有符号还是无符号。<br>赋值给无符号类型，当超过范围的时候取值为 the compiler assigns the remainder of that value modulo 256(unsigned char).<br>If we assign an out-of-range value to an object of signed type, the result is undefined. Don’t Mix Signed and Unsigned Types.</p>
<h4 id="2-1-3-Literals-字面常量"><a href="#2-1-3-Literals-字面常量" class="headerlink" title="2.1.3. Literals (字面常量)"></a>2.1.3. Literals (字面常量)</h4><p>最基本的类型推断是不是就像这个东西一样。转义字符最多就转义3个数字。</p>
<h3 id="2-2-Variables"><a href="#2-2-Variables" class="headerlink" title="2.2. Variables"></a>2.2. Variables</h3><p>初始化是在定义对象的时候给个初始值，赋值是删掉原有的值再给一个新值。所以要分清楚什么时候调用构造函数什么时候调用赋值操作符。<br>explicitly initialized 是要求构造对象的时候显示构造？<br>C++ is a statically typed language, which means that types are checked at compile time. 但是我可以通过模板(应该也是编译期确定的)或者继承等告诉运行时确定类型？</p>
<h3 id="2-3-Compound-Types"><a href="#2-3-Compound-Types" class="headerlink" title="2.3. Compound Types"></a>2.3. Compound Types</h3><p>rvalue reference These references are primarily intended for use inside classes. void*可以接收任何类型的指针，但是我们不能通过他使用指向的对象。需要先确定类型。<br>Because references are not objects, we may not define a reference to a reference. 所以右值引用还要理解这句话。<br>scope 内的指针不初始化那么值是未定义的，那全局指针被初始化什么 ？是 0 吗 ，因为全局区域全部被填充了 0 ？指针是类型但是引用不是。</p>
<h4 id="2-3-3-Understanding-Compound-Type-Declarations"><a href="#2-3-3-Understanding-Compound-Type-Declarations" class="headerlink" title="2.3.3. Understanding Compound Type Declarations"></a>2.3.3. Understanding Compound Type Declarations</h4><p>从右往左读取声明，第一个遇见的修饰符是变量类型，再往走的修饰符都是变量形容的类型，最前面是基类型。int *&amp;r = p; 引用类型，引用了指针类型，基类型是int。</p>
<h3 id="2-4-const-Qualifier"><a href="#2-4-const-Qualifier" class="headerlink" title="2.4. const Qualifier"></a>2.4. const Qualifier</h3><p>const int i = get_size(); // ok: initialized at run time。const Objects Are Local to a File。如果是compile-time constant那编译期会在使用的地方直接替换为值。<br>所以可以在不同文件中定义相同的 const 常量然后给不同的值？因为它只在当前文件可以访问？如果像多个文件公用一个运行期确定的常量，在声明和定义的地方都加上 extern。static is local ？<br>References to const 引用绑定的对象永远不可更改，所以都是const，“reference to const” 和 “const reference.” 都是说绑定的对象不可修改。const int &amp;r = ir; const 修饰 int。right to left;</p>
<pre><code>double dval = 3.14;
const int &amp;ri = dval;
// 当我们这样赋值的时候编译器做如下事情。我们不能通过临时对象更改原始对象。
const int temp = dval; // create a temporary const int from the double
const int &amp;ri = temp; // bind ri to that temporary
// 可以把非const 赋值给 const 引用，但是我们不能通过这个引用更改绑定的值，即便是绑定的值可以更改。
</code></pre><p>We use the term top-level const to indicate that the pointer itself is a const. When a pointer can point to a const object, we refer to that const as a low-level const.<br>When we copy an object, top-level consts are ignored。<br>A const object that is initialized from a constant expression is also a constant expression. const 对象用常量表达式初始化也是常量表达式，非const对象怎么都不是。<br>Generally, it is a good idea to use constexpr for variables that you intend to use as constant expressions。constexpr 显示表示必须用常量表达式赋值，包括常量函数。<br>constexpr 表示常量表达式，编译期必须可以推断。 const 表示赋值后不可修改，可以运行期赋值。</p>
<h3 id="2-5-Dealing-with-Types"><a href="#2-5-Dealing-with-Types" class="headerlink" title="2.5. Dealing with Types"></a>2.5. Dealing with Types</h3><p>类型别名不能简单的替换来解释。typedef char <em>pstring; const char </em>cstr = 0; // wrong interpretation of const pstring cstr ，const 用来修饰整体，常量指针。<br>By implication, a variable that uses auto as its type specifier must have an initializer，如果像auto保持 top-level const 属性必须显示声明。<br>没有底层属性的时候，称为顶层属性吗？</p>
<pre><code>When we ask for a reference to an auto-deduced type, top-level consts in the initializer are not ignored. // 显示 auto&amp; 被绑定的变量 const 属性保留
As usual, consts are not top-level when we bind a reference to an initializer. // 很难理解啊  const auto &amp; 用来形容被绑定的类型是 const 的。
</code></pre><p>decltype 当只想使用类型，不想用表达式初始化的时候使用，不需要执行表达式求结果。可以用来获取函数类型。decltype handles top-level const。<br>decltype returns a reference type for expressions that yield objects that can stand on the left-hand side of the assignment。并不是表达式的别名。<br>dereference operator 取消(解)引用返回的是引用类型。decltype(*p) is int&amp;, not plain int。</p>
<pre><code>// decltype of a parenthesized variable is always a reference
decltype((i)) d; // error: d is int&amp; and must be initialized // 每次去掉括号都执行一次  decltype ？像这样 decltype(decltype(i)) ？
decltype(i) e; // ok: e is an (uninitialized) int // double parentheses) is always a reference type，一层括号不是。
</code></pre><h3 id="2-6-Defining-Our-Own-Data-Structures"><a href="#2-6-Defining-Our-Own-Data-Structures" class="headerlink" title="2.6. Defining Our Own Data Structures"></a>2.6. Defining Our Own Data Structures</h3><p>The semicolon is needed because we can define variables after the class body，结构体或者类结尾括号后面一定要有分号。<br>in-class initializer 是编译期确定的还是运行期？还是由对象是不是常量决定？应该和普通的一样依据存储区域吧。<br>类定义不写到函数里面因为可见范围太小，当然是可以的。不写到CPP中因为写到头文件中，可以在多个头文件中引用。而不需要每个源文件都写相同的定义。当然一份定义多个声明也是可以的。<br>类定义到头文件后，我们还要避免多次包含头文件而有多个定义，使用预处理Preprocessor variable names do not respect C++ scoping rules.。当头文件更改的时候，需要重新编译源文件获取最新定义。<br>declarator(声明符) The part of a declaration that includes the name being defined and an optional type modifier.<br>temporary Unnamed object created by the compiler while evaluating an expression.<br>A temporary exists until the end of the largest expression that encloses the expression for which it was created.<br>void* Pointer type that can point to any nonconst type. Such pointers may not be dereferenced.<br>word The natural unit of integer computation on a given machine. Usually a word is large enough to hold an address. On a 32-bit machine a word is typically 4 bytes.</p>
<h2 id="Chapter-3-Strings-Vectors-and-Arrays"><a href="#Chapter-3-Strings-Vectors-and-Arrays" class="headerlink" title="Chapter 3. Strings, Vectors, and Arrays"></a>Chapter 3. Strings, Vectors, and Arrays</h2><p>使用等号的拷贝初始化编译器执行 string temp(10, ‘c’); // temp is cccccccccc 和 string s8 = temp; // copy temp into s8 两步，直接初始化不需要生成临时变量。？<br>当使用 + 操作符连接字符串的时候，必须每个 + 至少有一个是 string 类型。<br>Because references are not objects (§ 2.3.1, p. 50), we cannot have a vector of references。</p>
<h3 id="3-5-Arrays"><a href="#3-5-Arrays" class="headerlink" title="3.5. Arrays"></a>3.5. Arrays</h3><p>size_t is a machine-specific unsigned type that is guaranteed to be large enough to hold the size of any object in memory。</p>
<pre><code>int *ptrs[10]; // ptrs is an array of ten pointers to int
int &amp;refs[10] = /* ? */; // error: no arrays of references
int (*Parray)[10] = &amp;arr; // Parray points to an array of ten ints
int (&amp;arrRef)[10] = arr; // arrRef refers to an array of ten ints

auto ia2(ia); // ia2 is an int* that points to the first element in ia。
The type returned by decltype(ia) is array of ten ints
</code></pre><p>Like size_t, the ptrdiff_t type is a machine-specific type。</p>
<p>当前指向的位置，然后往后计算。有趣</p>
<pre><code>int *p = &amp;ia[2]; // p points to the element indexed by 2
int j = p[1]; // p[1] is equivalent to *(p + 1),
// p[1] is the same element as ia[3]
int k = p[-2]; // p[-2] is the same element as ia[0]
</code></pre><h3 id="3-6-Multidimensional-Arrays"><a href="#3-6-Multidimensional-Arrays" class="headerlink" title="3.6. Multidimensional Arrays"></a>3.6. Multidimensional Arrays</h3><p>多维数组实际布局也是连续的，所以可以接着选取？外层 for 范围循环总是用引用，避免被转换为指针。二维数组第一维是啥类型？不适用auto的时候for (int (*p)[4] = ai;;;) 这样定义？</p>
<pre><code>// assigns the first element of arr to the last element in the last row of ia
ia[2][3] = arr[0][0][0];
int (&amp;row)[4] = ia[1]; // binds row to the second four-element array in ia

size_t cnt = 0;
for (auto &amp;row : ia) // for every element in the outer array
    for (auto &amp;col : row) { // for every element in the inner array
        col = cnt; // give this element the next value
        ++cnt; // increment cnt
    }
</code></pre><p>Type Aliases Simplify Pointers to Multidimensional Arrays. using int_array = int[4]; for (int_array *p = ia; p != ia + 3; ++p)<br>value initialization 当不提供值的时候，或者没有默认构造函数的时候，使用拷贝编译器生成的变量初始化。提供了值才是值初始化。使用括号初始化的时候，什么时候是赋值初始化，什么时候是拷贝初始化。</p>
<h2 id="Chapter-4-Expressions"><a href="#Chapter-4-Expressions" class="headerlink" title="Chapter 4. Expressions"></a>Chapter 4. Expressions</h2><p>when we use an object as an rvalue, we use the object’s value (its contents). When we use an object as an lvalue, we use the object’s identity (its location in memory).<br>we apply decltype to an expression (other than a variable), the result is a reference type if the expression yields an lvalue.decltype(<em>p) is int&amp;. decltype(&amp;p) is int**,<br>没有定义操作符操作数的执行顺序，方便编译器进行优化。If you change the value of an operand, don’t use that operand elsewhere in the same expresion.<br>Compound Assignment Operators 只计算一次，a op= b == a = a op b; 除了性能上有一点点差异，两种完全相同。非组合的计算两次，一次在右边op一次在左边 = 。<br>后加加优先级更高，所以 </em>pbeg++ is equivalent to *(pbeg++).</p>
<h3 id="4-6-The-Member-Access-Operators"><a href="#4-6-The-Member-Access-Operators" class="headerlink" title="4.6. The Member Access Operators"></a>4.6. The Member Access Operators</h3><h3 id="4-8-The-Bitwise-Operators"><a href="#4-8-The-Bitwise-Operators" class="headerlink" title="4.8. The Bitwise Operators"></a>4.8. The Bitwise Operators</h3><p>Moreover, doing a left shift that changes the value of the sign bit is undefined.</p>
<h3 id="4-9-The-sizeof-Operator"><a href="#4-9-The-sizeof-Operator" class="headerlink" title="4.9. The sizeof Operator"></a>4.9. The sizeof Operator</h3><p>The sizeof operator is unusual in that it does not evaluate its operand。sizeof returns a constant expression。返回常量表达式，可以用来确定数组大小。<br>sizeof (type) 类型大小，这个可以传递变量在括号里面吗？应该是不行的吧， sizeof expr 表达式类型的大小，returns the size of the type returned by the given expression.。<br>we can use the scope operator to ask for the size of a member of a class type。Note that sizeof does not convert the array to a pointer.</p>
<pre><code>// sizeof(ia)/sizeof(*ia) returns the number of elements in ia
constexpr size_t sz = sizeof(ia)/sizeof(*ia);
int arr2[sz]; // ok sizeof returns a constant expression
</code></pre><p>sizeof a string or a vector returns only the size of the fixed part of these types; it does not return the size used by the object’s elements. ？？？</p>
<h4 id="4-11-1-The-Arithmetic-Conversions"><a href="#4-11-1-The-Arithmetic-Conversions" class="headerlink" title="4.11.1. The Arithmetic Conversions"></a>4.11.1. The Arithmetic Conversions</h4><p>When the signedness differs and the type of the unsigned operand is the same as or larger than that of the signed operand, the signed operand is converted to unsigned.<br>A const_cast changes only a low-level (§ 2.4.3, p. 63) const in its operand。所以类型本来的那个const是底层的，复合类型带的那个是顶层的。</p>
<h2 id="Chapter-5-Statements"><a href="#Chapter-5-Statements" class="headerlink" title="Chapter 5. Statements"></a>Chapter 5. Statements</h2><p>dangling else 匹配最近不匹配的 if。switch 执行第一个 case 开始，如果没有遇见 break，会一直执行后续case 即便是不匹配。不允许跳过case定义的变量。<br>we can do so by defining the variable inside a block, thereby ensuring that the variable is out of scope at the point of any subsequent label.<br>for (auto &amp;r : v)  ==   for (auto beg = v.begin(), end = v.end(); beg != end; ++beg) {auto &amp;r = *beg;} 缓存end？不能用来向容器中添加元素？<br>A do while ends with a semicolon after the parenthesized condition. Variables used in condition must be defined outside the body of the do while statement.<br>goto 使用的 Label 独立于变量系统，可以和任何变量重复，但是必须和 goto 在同一个函数内。goto同样不允许跳过变量定义。可以往会跳跃，并且销毁再重新构造变量。不建议使用。<br>Caution: Writing Exception Safe Code is Hard。书写异常安全的程序是很难的，异常这块还是要好好接触一下的。</p>
<h2 id="Chapter-6-Functions"><a href="#Chapter-6-Functions" class="headerlink" title="Chapter 6. Functions"></a>Chapter 6. Functions</h2>
    </div>

    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">theForger</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2016/12/02/reading-note-two/" class="pre-post btn btn-default" title='C++ Primer, Fifth Edition reading-note-two'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">C++ Primer, Fifth Edition reading-note-two</span>
        </a>
    
    
</div>


    <div id="comments">
        
	
  <script id="dsq-count-scr" src="https://israel-liu.disqus.com/count.js" async></script>


<script type="text/javascript">
  var disqus_config = function () {
    this.page.url = 'https://israel-liu.github.io/2016/12/01/reading-note-one/';
    this.page.identifier = '2016/12/01/reading-note-one/';
    this.page.title = 'C++ Primer, Fifth Edition reading_note_one';
  };
  var d = document, s = d.createElement('script');
  s.src = 'https://israel-liu.disqus.com/embed.js';
  s.setAttribute('data-timestamp', '' + +new Date());
  (d.head || d.body).appendChild(s);
</script>


	

    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#下面正文开始"><span class="toc-text">下面正文开始</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Top-Level-const"><span class="toc-text">Top-Level const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#example"><span class="toc-text">example</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Standard-Container-Iterator-Operations"><span class="toc-text">Standard Container Iterator Operations</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文章结束之前提一下-begin-end"><span class="toc-text">文章结束之前提一下 begin(),  end().</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#End-第一篇到这里了，Note-还有个vector无符号下标，内置数组有符号下标"><span class="toc-text">End 第一篇到这里了，Note 还有个vector无符号下标，内置数组有符号下标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-1-Getting-Started"><span class="toc-text">Chapter 1. Getting Started</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-I-The-Basics"><span class="toc-text">Part I: The Basics</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-2-Variables-and-Basic-Types"><span class="toc-text">Chapter 2. Variables and Basic Types</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-Literals-字面常量"><span class="toc-text">2.1.3. Literals (字面常量)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Variables"><span class="toc-text">2.2. Variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Compound-Types"><span class="toc-text">2.3. Compound Types</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-Understanding-Compound-Type-Declarations"><span class="toc-text">2.3.3. Understanding Compound Type Declarations</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-const-Qualifier"><span class="toc-text">2.4. const Qualifier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-Dealing-with-Types"><span class="toc-text">2.5. Dealing with Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-Defining-Our-Own-Data-Structures"><span class="toc-text">2.6. Defining Our Own Data Structures</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-3-Strings-Vectors-and-Arrays"><span class="toc-text">Chapter 3. Strings, Vectors, and Arrays</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-Arrays"><span class="toc-text">3.5. Arrays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-Multidimensional-Arrays"><span class="toc-text">3.6. Multidimensional Arrays</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-4-Expressions"><span class="toc-text">Chapter 4. Expressions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-The-Member-Access-Operators"><span class="toc-text">4.6. The Member Access Operators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-The-Bitwise-Operators"><span class="toc-text">4.8. The Bitwise Operators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-The-sizeof-Operator"><span class="toc-text">4.9. The sizeof Operator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-11-1-The-Arithmetic-Conversions"><span class="toc-text">4.11.1. The Arithmetic Conversions</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-5-Statements"><span class="toc-text">Chapter 5. Statements</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-6-Functions"><span class="toc-text">Chapter 6. Functions</span></a></li></ol>
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<!--<a id="toc-btn">
    <i class="fa fa-bars"></i>
</a>-->

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12"> 
                <span>Copyright &copy; 2017
                </span> | 
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> | 
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>



	<script src="/js/search.js?rev=@@hash"></script>


<script src="/js/app.js?rev=@@hash"></script>


</body>
</html>