<!DOCTYPE HTML>
<html lang="null">
<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="五年C++程序员的口水博客">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="https://israel-liu.github.io">
    <!--SEO-->





<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->


<title>The_Cpp_Standard_Library_A_Tutorial_and_Reference_2nd_Edition | 五年C++程序员的口水博客</title>


    <link rel="alternate" href="/atom.xml" title="五年C++程序员的口水博客" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    
</head>


<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(https://github.com/israel-Liu/theForger/raw/master/images/byosoku.jpg)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='Licca Chen'>
            <img src="/img/avatar.JPG" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                 <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
    	</div>
    </div>
</header>

    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="https://israel-liu.github.io">五年C++程序员的口水博客</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>Home</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>timeline</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/tags/"><i class="fa "></i>Tags</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/about/"><i class="fa "></i>About</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="The_Cpp_Standard_Library_A_Tutorial_and_Reference_2nd_Edition">
            
	            The_Cpp_Standard_Library_A_Tutorial_and_Reference_2nd_Edition
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/ ">
             
        </a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2019/01/23</span>
        </span>
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <p>最近看了WIN核心编程后想再提升下C++语言方面的知识，访问了网站 <a href="https://isocpp.org/get-started" target="_blank" rel="noopener">IsoCpp</a>，看到了几本相关书籍。   </p>
<p>经大佬前同事推荐然后选择先看这本书，首先这本书在我两年前看C++ Primer的时候是看过的。当初是从会用的角度，再看一遍以用好为目标。</p>
<pre><code>### Looking for the authoritative tutorial and reference for the C++ standard library?    

A Tutorial and Reference by renowned ISO C++ member Nicolai Josuttis is the most respected book for learning and studying the standard library.    

It provides comprehensive documentation of each library component, including an introduction to its purpose and design; clearly written explanations of complex concepts;    

the practical programming details needed for effective use; traps and pitfalls; the exact signature and definition of the most important classes and functions;    

and numerous examples of working code. You’ll find it all here – everything from concurrency and clocks, to the new hash-based containers and regular expressions,    
to high-quality guidance on how to use key language features like lambdas with it all.
</code></pre><h2 id="Preface-to-the-Second-Edition"><a href="#Preface-to-the-Second-Edition" class="headerlink" title="Preface to the Second Edition"></a>Preface to the Second Edition</h2><h2 id="Acknowledgments-for-the-Second-Edition"><a href="#Acknowledgments-for-the-Second-Edition" class="headerlink" title="Acknowledgments for the Second Edition"></a>Acknowledgments for the Second Edition</h2><h2 id="Preface-to-the-First-Edition"><a href="#Preface-to-the-First-Edition" class="headerlink" title="Preface to the First Edition"></a>Preface to the First Edition</h2><h2 id="Acknowledgments-for-the-First-Edition"><a href="#Acknowledgments-for-the-First-Edition" class="headerlink" title="Acknowledgments for the First Edition"></a>Acknowledgments for the First Edition</h2><h1 id="Chapter-1-About-This-Book"><a href="#Chapter-1-About-This-Book" class="headerlink" title="Chapter 1 : About This Book"></a>Chapter 1 : About This Book</h1><h3 id="1-1-Why-This-Book"><a href="#1-1-Why-This-Book" class="headerlink" title="1.1 Why This Book"></a>1.1 Why This Book</h3><p>本书从概念的角度介绍了C11的库和组件，描述了使用细节。使用示例来演示组件的精确使用。</p>
<h3 id="1-2-Before-Reading-This-Book"><a href="#1-2-Before-Reading-This-Book" class="headerlink" title="1.2 Before Reading This Book"></a>1.2 Before Reading This Book</h3><p>主要描述库的实现细节，所以要求具备一定C++基础。</p>
<h3 id="1-3-Style-and-Structure-of-the-Book"><a href="#1-3-Style-and-Structure-of-the-Book" class="headerlink" title="1.3 Style and Structure of the Book"></a>1.3 Style and Structure of the Book</h3><p>本书先介绍了一般概念和库使用的实用程序(utilities), 然后在一章或多章介绍components第一个介绍STL。最后描述self-explanatory components。  </p>
<p>每个组件介绍从设计目的和用途开始，然后介绍使用方法和避免陷阱，最后细节描述和reference。</p>
<h3 id="1-4-How-to-Read-This-Book"><a href="#1-4-How-to-Read-This-Book" class="headerlink" title="1.4 How to Read This Book"></a>1.4 How to Read This Book</h3><p>作为C++程序员就是从头阅读到位，然后自己使用组件编码。</p>
<h2 id="Chapter-2-Introduction-to-C-and-the-Standard-Library"><a href="#Chapter-2-Introduction-to-C-and-the-Standard-Library" class="headerlink" title="Chapter 2 Introduction to C++ and the Standard Library"></a>Chapter 2 Introduction to C++ and the Standard Library</h2><h3 id="2-1-History-of-the-C-Standards"><a href="#2-1-History-of-the-C-Standards" class="headerlink" title="2.1 History of the C++ Standards"></a>2.1 History of the C++ Standards</h3><p>第一个C++标准1998年发布的C++98，2003年对第一个标准打了补丁叫C++03，2007年发布了TR1是一个库扩展技术报告包含在std::tr1命名空间。  </p>
<p>C++0x是C++11的早期项目名称于2011年作为第二版标准发布称为C++11.这个可以本书侧重点。</p>
<h4 id="2-1-1-Common-Questions-about-the-C-11-Standard"><a href="#2-1-1-Common-Questions-about-the-C-11-Standard" class="headerlink" title="2.1.1 Common Questions about the C++11 Standard"></a>2.1.1 Common Questions about the C++11 Standard</h4><h4 id="2-1-2-Compatibility-between-C-98-and-C-11"><a href="#2-1-2-Compatibility-between-C-98-and-C-11" class="headerlink" title="2.1.2 Compatibility between C++98 and C++11"></a>2.1.2 Compatibility between C++98 and C++11</h4><pre><code>For C++11, the following definition holds when compiling a C++ translation unit:
#define __cplusplus 201103L
By contrast, with both C++98 and C++03, it was:
#define __cplusplus 199711L
</code></pre><p>C++11编译器向后兼容C++98可以正确编译C++98标准的源代码，但是符合C++11标准的连接器没法正确连接C++98编译过的二进制。</p>
<h3 id="2-2-Complexity-and-Big-O-Notation"><a href="#2-2-Complexity-and-Big-O-Notation" class="headerlink" title="2.2 Complexity and Big-O Notation"></a>2.2 Complexity and Big-O Notation</h3><p>主要用来衡量算法效率的概念，不考虑其它时间消耗，不如插入效率不考虑内存不够需要分配内存所花费的时候。amortized？</p>
<h2 id="Chapter-3-New-Language-Features"><a href="#Chapter-3-New-Language-Features" class="headerlink" title="Chapter 3 : New Language Features"></a>Chapter 3 : New Language Features</h2><h3 id="3-1-New-C-11-Language-Features"><a href="#3-1-New-C-11-Language-Features" class="headerlink" title="3.1 New C++11 Language Features"></a>3.1 New C++11 Language Features</h3><h4 id="3-1-1-Important-Minor-Syntax-Cleanups"><a href="#3-1-1-Important-Minor-Syntax-Cleanups" class="headerlink" title="3.1.1 Important Minor Syntax Cleanups"></a>3.1.1 Important Minor Syntax Cleanups</h4><p>nullptr 类型是 std::nullptr_t 可以赋值为各种指针类型。</p>
<h4 id="3-1-2-Automatic-Type-Deduction-with-auto"><a href="#3-1-2-Automatic-Type-Deduction-with-auto" class="headerlink" title="3.1.2 Automatic Type Deduction with auto"></a>3.1.2 Automatic Type Deduction with auto</h4><p><a href="https://www.youtube.com/watch?v=wQxj20X-tIU" target="_blank" rel="noopener">CppCon 2014: Scott Meyers “Type Deduction and Why You Care”</a></p>
<h4 id="3-1-3-Uniform-Initialization-and-Initializer-Lists"><a href="#3-1-3-Uniform-Initialization-and-Initializer-Lists" class="headerlink" title="3.1.3 Uniform Initialization and Initializer Lists"></a>3.1.3 Uniform Initialization and Initializer Lists</h4><p>C++11开始所有初始化都可以使用大括号。传递错误类型可能会导致初始化失败。std::initializer_list&lt;&gt;可以用来处理一列数据。</p>
<pre><code>int x1(5.3); // OK, but OUCH: x1 becomes 5
int x2 = 5.3; // OK, but OUCH: x2 becomes 5
int x3{5.0}; // ERROR: narrowing
int x4 = {5.3}; // ERROR: narrowing
char c1{7}; // OK: even though 7 is an int, this is not narrowing
char c2{99999}; // ERROR: narrowing (if 99999 doesn’t fit into a char)
std::vector&lt;int&gt; v1 { 1, 2, 4, 5 }; // OK
std::vector&lt;int&gt; v2 { 1, 2.3, 4, 5.6 }; // ERROR: narrowing doubles to ints
</code></pre><p>explicit 关键字和 initializer lists 的结合使用，可以显示初始化多个值。</p>
<pre><code>Because of initializer lists, explicit now also becomes relevant for constructors taking more than one argument. 
So, you can now disable automatic type conversions from multiple values, which is also used when an initialization uses the = syntax:
In the same manner, an explicit constructor taking an initializer list disables implicit conversions for initializer lists with zero, one, or more initial values.
</code></pre><h4 id="3-1-4-Range-Based-for-Loops"><a href="#3-1-4-Range-Based-for-Loops" class="headerlink" title="3.1.4 Range-Based for Loops"></a>3.1.4 Range-Based for Loops</h4><p>添加引用避免拷贝。auto == vec 元素类型。No explicit type conversions are possible when elements are initialized as decl inside the for loop.</p>
<pre><code>for ( auto&amp; elem : vec ) {
    elem *= 3;
}
</code></pre><h4 id="3-1-5-Move-Semantics-and-Rvalue-References"><a href="#3-1-5-Move-Semantics-and-Rvalue-References" class="headerlink" title="3.1.5 Move Semantics and Rvalue References"></a>3.1.5 Move Semantics and Rvalue References</h4><p>当调用者不再使用传递的参数时，可以使用移动语义避免拷贝。右值只能出现在等号右边为啥还可以修改？<br>使用右值构造的对象，就相当于View如果他具备Owner就可以修改内部数据。如std::string内部维护的内存字符。</p>
<pre><code>Thus, you usually have to clear the contents of the passed argument (for example, by assigning nullptr to its internal member referring to its elements).
</code></pre><h4 id="3-1-6-New-String-Literals"><a href="#3-1-6-New-String-Literals" class="headerlink" title="3.1.6 New String Literals"></a>3.1.6 New String Literals</h4><p>原始字符串定义多用于正则表达式。</p>
<h4 id="3-1-7-Keyword-noexcept"><a href="#3-1-7-Keyword-noexcept" class="headerlink" title="3.1.7 Keyword noexcept"></a>3.1.7 Keyword noexcept</h4><p>不确定如何补救的行为不抛出异常可以节约运行开销，只有出现异常无法执行的情况才需要抛出异常。</p>
<pre><code>If foo() throws — the program is terminated, calling std::terminate(), which by default calls std::abort()
</code></pre><h4 id="3-1-8-Keyword-constexpr"><a href="#3-1-8-Keyword-constexpr" class="headerlink" title="3.1.8 Keyword constexpr"></a>3.1.8 Keyword constexpr</h4><p>用来在编译期确定表达式的值(metaprogramming)可以用表达式指定数值大小了。</p>
<pre><code>std::array&lt;float, std::numeric_limits&lt;short&gt;::max()&gt; a; // Since C++ 11
</code></pre><h4 id="3-1-9-New-Template-Features"><a href="#3-1-9-New-Template-Features" class="headerlink" title="3.1.9 New Template Features"></a>3.1.9 New Template Features</h4><pre><code>Note that it is currently under discussion whether the following example also is valid. The reason is
that formally for a single argument the variadic form is ambiguous with the nonvariadic form for a
single argument; however, compilers usually accept this code:
template &lt;typename T&gt;
void print (const T&amp; arg)
{
    std::cout &lt;&lt; arg &lt;&lt; std::endl;
}
template &lt;typename T, typename... Types&gt;
void print (const T&amp; firstArg, const Types&amp;... args)
{
    std::cout &lt;&lt; firstArg &lt;&lt; std::endl; // print first argument
    print(args...); // call print() for remaining arguments
}
Inside variadic templates, sizeof...(args) yields the number of arguments.
Class std::tuple&lt;&gt; makes heavy use of this feature (see Section 5.1.2, page 68).
</code></pre><h4 id="3-1-10-Lambdas"><a href="#3-1-10-Lambdas" class="headerlink" title="3.1.10 Lambdas"></a>3.1.10 Lambdas</h4><p>使用mutable可以对按值捕获的外部变量进行改变。</p>
<h4 id="3-1-11-Keyword-decltype"><a href="#3-1-11-Keyword-decltype" class="headerlink" title="3.1.11 Keyword decltype"></a>3.1.11 Keyword decltype</h4><p>可以让编译器找到表达式类型。</p>
<h4 id="3-1-12-New-Function-Declaration-Syntax"><a href="#3-1-12-New-Function-Declaration-Syntax" class="headerlink" title="3.1.12 New Function Declaration Syntax"></a>3.1.12 New Function Declaration Syntax</h4><pre><code>template &lt;typename T1, typename T2&gt;
auto add(T1 x, T2 y) -&gt; decltype(x+y);
</code></pre><h4 id="3-1-13-Scoped-Enumerations"><a href="#3-1-13-Scoped-Enumerations" class="headerlink" title="3.1.13 Scoped Enumerations"></a>3.1.13 Scoped Enumerations</h4><p>使用std::underlying_type可以获取底层类型。<br>    enum class Salutation : char { mr, ms, co, none }; </p>
<h4 id="3-1-14-New-Fundamental-Data-Types"><a href="#3-1-14-New-Fundamental-Data-Types" class="headerlink" title="3.1.14 New Fundamental Data Types"></a>3.1.14 New Fundamental Data Types</h4><pre><code>• char16_t and char32_t
• long long and unsigned long long
• std::nullptr_t
</code></pre><h3 id="3-2-Old-“New”-Language-Features"><a href="#3-2-Old-“New”-Language-Features" class="headerlink" title="3.2 Old “New” Language Features"></a>3.2 Old “New” Language Features</h3><pre><code>// Nontype Template Parameters
bitset&lt;32&gt; flags32; // bitset with 32 bits
bitset&lt;50&gt; flags50; // bitset with 50 bits



// Default Template Parameters
template &lt;typename T, typename container = vector&lt;T&gt;&gt;
class MyClass;



// Keyword typename 这个在STL里面太常见了，理解了可以更好理解源码
template &lt;typename T&gt;
class MyClass {
    typename T::SubType * ptr;  // 这里声明是SubType个类型，要求T里面提供类型SubType
    ...
};

class Q {
    typedef int SubType;
    ...
};
MyClass&lt;Q&gt; x; // OK



// Member Templates 模板构造函数。C++模板还是强大啊，还需要好好理解。
class MyClass {
    ...
    template &lt;typename T&gt;
    void f(T);                   // 这里f可以接收人任何类型的参数。
};

template &lt;typename T&gt;
class MyClass {
    private:
        T value; // Support automatic type conversions for members in class templates.
    public:
        void assign (const MyClass&lt;T&gt;&amp; x) { // x must have same type as *this
            value = x.value;
        }
    ...
};
</code></pre><h4 id="3-2-1-Explicit-Initialization-for-Fundamental-Types"><a href="#3-2-1-Explicit-Initialization-for-Fundamental-Types" class="headerlink" title="3.2.1 Explicit Initialization for Fundamental Types"></a>3.2.1 Explicit Initialization for Fundamental Types</h4><pre><code>template &lt;typename T&gt;
void f()
{
    T x = T(); // zero initialized 我想这是个新叫法。没有的话使用
    ...
}
</code></pre><h4 id="3-2-2-Definition-of-main"><a href="#3-2-2-Definition-of-main" class="headerlink" title="3.2.2 Definition of main()"></a>3.2.2 Definition of main()</h4><p>return 0; 不是必须的，可以调用 exit()，quick_exit()，terminate()。</p>
<h2 id="Chapter-4-General-Concepts"><a href="#Chapter-4-General-Concepts" class="headerlink" title="Chapter 4 General Concepts"></a>Chapter 4 General Concepts</h2><h3 id="4-1-Namespace-std"><a href="#4-1-Namespace-std" class="headerlink" title="4.1 Namespace std"></a>4.1 Namespace std</h3><p>Unlike a class, a namespace is open for extensions that might occur at any source。<br>Thus, you could use a namespace to define components that are distributed over several physical modules.<br>要小心在头文件中使用 using namespace std; 这可能会导致名字冲突或因为重载导致不同行为。</p>
<h3 id="4-2-Header-Files"><a href="#4-2-Header-Files" class="headerlink" title="4.2 Header Files"></a>4.2 Header Files</h3><pre><code>#include &lt;string&gt;         // 新的形式包含在 std 中
#include &lt;cstring&gt;      // 老式头的新文件在 std 中
#include &lt;stdlib.h&gt;     // 老版头在 std 和全局空间都有声明。
#include &lt;iostream.h&gt;     // 废弃的老版本C++头文件格式。
</code></pre><h3 id="4-3-Error-and-Exception-Handling"><a href="#4-3-Error-and-Exception-Handling" class="headerlink" title="4.3 Error and Exception Handling"></a>4.3 Error and Exception Handling</h3><p>像 string 会检查可能错误并抛出异常。STL更喜欢效率很少检查逻辑错误，只在运行时出错抛出异常。</p>
<h4 id="4-3-1-Standard-Exception-Classes"><a href="#4-3-1-Standard-Exception-Classes" class="headerlink" title="4.3.1 Standard Exception Classes"></a>4.3.1 Standard Exception Classes</h4><p>所有异常语言的还是库的都从exception类继承。<img src="https://github.com/israel-Liu/theForger/raw/master/images/exception.png" alt=""></p>
<h4 id="4-3-2-Members-of-Exception-Classes"><a href="#4-3-2-Members-of-Exception-Classes" class="headerlink" title="4.3.2 Members of Exception Classes"></a>4.3.2 Members of Exception Classes</h4><p>错误条件(std::error_condition) -&gt; 条件枚举值，错误代码(std::error_code) -&gt; 含义。 ec is a error object.<br><a href="https://www.youtube.com/watch?v=LDxAgMe6D18&amp;index=9&amp;list=PLHTh1InhhwT7esTl1bRitiizeEnksGU7J&amp;t=0s" target="_blank" rel="noopener">Modernizing Legacy C++ Code</a><br>    if (ec == std::errc::invalid_argument) { // check for specific error condition<br>    …<br>    }<br>    if (ec == std::future_errc::no_state) { // check for specific error code<br>    …<br>    }</p>
<h4 id="4-3-3-Passing-Exceptions-with-Class-exception-ptr"><a href="#4-3-3-Passing-Exceptions-with-Class-exception-ptr" class="headerlink" title="4.3.3 Passing Exceptions with Class exception_ptr"></a>4.3.3 Passing Exceptions with Class exception_ptr</h4><p>This feature is especially useful to pass exception between threads (see Section 18.2.1, page 964).</p>
<h4 id="4-3-4-Throwing-Standard-Exceptions"><a href="#4-3-4-Throwing-Standard-Exceptions" class="headerlink" title="4.3.4 Throwing Standard Exceptions"></a>4.3.4 Throwing Standard Exceptions</h4><p>非语言基本的异常错误(bad_cast, bad_typeid, bad_exception)都可以通过 what() 返回值进行构造异常对象。<br>    throw std::out_of_range (“out_of_range (somewhere, somehow)”);<br>    throw std::system_error (std::make_error_code(std::errc::invalid_argument), “argument … is not valid”);</p>
<h4 id="4-3-5-Deriving-from-Standard-Exception-Classes"><a href="#4-3-5-Deriving-from-Standard-Exception-Classes" class="headerlink" title="4.3.5 Deriving from Standard Exception Classes"></a>4.3.5 Deriving from Standard Exception Classes</h4><p>继承基类 exception 并且实现虚函数 what() 和 code() Shample: Stack in Section 12.1.3, page 635.</p>
<h4 id="4-4-Callable-Objects"><a href="#4-4-Callable-Objects" class="headerlink" title="4.4 Callable Objects"></a>4.4 Callable Objects</h4><pre><code>• A function, where additional args are passed to as arguments
• A pointer to a member function, which is called for the object passed as the first additional
  argument (must be reference or pointer) and gets the remaining arguments as member function parameters
• A function object (operator () for a passed object), where additional args are passed as arguments
• A lambda (see Section 3.1.10, page 28), which strictly speaking is a kind of function object
</code></pre><h4 id="4-5-Concurrency-and-Multithreading"><a href="#4-5-Concurrency-and-Multithreading" class="headerlink" title="4.5 Concurrency and Multithreading"></a>4.5 Concurrency and Multithreading</h4><p>STL是共享的当同时使用构造的对象时候就要考虑同步。<a href="https://www.youtube.com/watch?v=y0GSc5fKtl8&amp;t=2229s" target="_blank" rel="noopener">Overview of Parallel Programming in C++</a></p>
<h4 id="4-6-Allocators"><a href="#4-6-Allocators" class="headerlink" title="4.6 Allocators"></a>4.6 Allocators</h4><p>分配器为分配内存加了一层封装，可以指定如何分配内存。默认分配器比较常用。后面细看都可以用于共享内存等哪些实现。</p>
<h2 id="Chapter-5-Utilities"><a href="#Chapter-5-Utilities" class="headerlink" title="Chapter 5 Utilities"></a>Chapter 5 Utilities</h2><pre><code>Type traits are used wherever complicated type conversions are necessary.
</code></pre><h3 id="5-1-Pairs-and-Tuples"><a href="#5-1-Pairs-and-Tuples" class="headerlink" title="5.1 Pairs and Tuples"></a>5.1 Pairs and Tuples</h3><h4 id="5-1-1-Pairs"><a href="#5-1-1-Pairs" class="headerlink" title="5.1.1 Pairs"></a>5.1.1 Pairs</h4><h4 id="5-1-2-Tuples"><a href="#5-1-2-Tuples" class="headerlink" title="5.1.2 Tuples"></a>5.1.2 Tuples</h4><h4 id="5-1-3-I-O-for-Tuples"><a href="#5-1-3-I-O-for-Tuples" class="headerlink" title="5.1.3 I/O for Tuples"></a>5.1.3 I/O for Tuples</h4><p>这个在boost里面有实现大量使用metaprogramming，并没有被移植到STL中。</p>
<h4 id="5-1-4-Conversions-between-tuples-and-pairs"><a href="#5-1-4-Conversions-between-tuples-and-pairs" class="headerlink" title="5.1.4 Conversions between tuples and pairs"></a>5.1.4 Conversions between tuples and pairs</h4><h3 id="5-2-Smart-Pointers"><a href="#5-2-Smart-Pointers" class="headerlink" title="5.2 Smart Pointers"></a>5.2 Smart Pointers</h3><h4 id="5-2-1-Class-shared-ptr"><a href="#5-2-1-Class-shared-ptr" class="headerlink" title="5.2.1 Class shared_ptr"></a>5.2.1 Class shared_ptr</h4><p>提供 operators * and -&gt; 就像使用原始指针一样使用智能指针对象。</p>
<h4 id="5-2-2-Class-weak-ptr"><a href="#5-2-2-Class-weak-ptr" class="headerlink" title="5.2.2 Class weak_ptr"></a>5.2.2 Class weak_ptr</h4><p>The lifetime of a reference to an object outlives the object it refers to. weak_ptr 对象生命周期长于它引用的对象。</p>
<h4 id="5-2-3-Misusing-Shared-Pointers"><a href="#5-2-3-Misusing-Shared-Pointers" class="headerlink" title="5.2.3 Misusing Shared Pointers"></a>5.2.3 Misusing Shared Pointers</h4><p>Only one group of shared pointers owns an object. 防止多次析构。还有很多坑没搞清楚前不要乱用。</p>
<h4 id="5-2-4-Shared-and-Weak-Pointers-in-Detail"><a href="#5-2-4-Shared-and-Weak-Pointers-in-Detail" class="headerlink" title="5.2.4 Shared and Weak Pointers in Detail"></a>5.2.4 Shared and Weak Pointers in Detail</h4><h4 id="5-2-5-Class-unique-ptr"><a href="#5-2-5-Class-unique-ptr" class="headerlink" title="5.2.5 Class unique_ptr"></a>5.2.5 Class unique_ptr</h4><h4 id="5-2-6-Class-unique-ptr-in-Detail"><a href="#5-2-6-Class-unique-ptr-in-Detail" class="headerlink" title="5.2.6 Class unique_ptr in Detail"></a>5.2.6 Class unique_ptr in Detail</h4><h4 id="5-2-7-Class-auto-ptr"><a href="#5-2-7-Class-auto-ptr" class="headerlink" title="5.2.7 Class auto_ptr"></a>5.2.7 Class auto_ptr</h4><h4 id="5-2-8-Final-Words-on-Smart-Pointers"><a href="#5-2-8-Final-Words-on-Smart-Pointers" class="headerlink" title="5.2.8 Final Words on Smart Pointers"></a>5.2.8 Final Words on Smart Pointers</h4><h3 id="5-3-Numeric-Limits"><a href="#5-3-Numeric-Limits" class="headerlink" title="5.3 Numeric Limits"></a>5.3 Numeric Limits</h3><p>模板特殊化numeric_limits可以使用依赖平台的基础类型</p>
<h3 id="5-4-Type-Traits-and-Type-Utilities"><a href="#5-4-Type-Traits-and-Type-Utilities" class="headerlink" title="5.4 Type Traits and Type Utilities"></a>5.4 Type Traits and Type Utilities</h3><h4 id="5-4-1-Purpose-of-Type-Traits"><a href="#5-4-1-Purpose-of-Type-Traits" class="headerlink" title="5.4.1 Purpose of Type Traits"></a>5.4.1 Purpose of Type Traits</h4><pre><code>template &lt;typename T1, typename T2&gt;
struct common_type&lt;T1, T2&gt; {
    typedef decltype(true ? declval&lt;T1&gt;() : declval&lt;T2&gt;()) type; // true ?
};
</code></pre><h4 id="5-4-2-Type-Traits-in-Detail"><a href="#5-4-2-Type-Traits-in-Detail" class="headerlink" title="5.4.2 Type Traits in Detail"></a>5.4.2 Type Traits in Detail</h4><p><a href="https://blog.csdn.net/LaoJiu_/article/details/66472089" target="_blank" rel="noopener">trivial type</a><br>Note again that a reference to a constant type is not constant, so you can’t remove constness there.</p>
<h4 id="5-4-3-Reference-Wrappers"><a href="#5-4-3-Reference-Wrappers" class="headerlink" title="5.4.3 Reference Wrappers"></a>5.4.3 Reference Wrappers</h4><pre><code>std::vector&lt;std::reference_wrapper&lt;MyClass&gt;&gt; coll;
</code></pre><h4 id="5-4-4-Function-Type-Wrappers"><a href="#5-4-4-Function-Type-Wrappers" class="headerlink" title="5.4.4 Function Type Wrappers"></a>5.4.4 Function Type Wrappers</h4><pre><code>class C {
public:
    void memfunc (int x, int y) const;
};
std::function&lt;void(const C&amp;,int,int)&gt; mf;
mf = &amp;C::memfunc;
mf(C(),42,77);
</code></pre><h3 id="5-5-Auxiliary-Functions"><a href="#5-5-Auxiliary-Functions" class="headerlink" title="5.5 Auxiliary Functions"></a>5.5 Auxiliary Functions</h3><h4 id="5-5-1-Processing-the-Minimum-and-Maximum"><a href="#5-5-1-Processing-the-Minimum-and-Maximum" class="headerlink" title="5.5.1 Processing the Minimum and Maximum"></a>5.5.1 Processing the Minimum and Maximum</h4><p>For an initializer list, you need an internal temporary, so returning a reference would return a dangling reference.</p>
<h4 id="5-5-2-Swapping-Two-Values"><a href="#5-5-2-Swapping-Two-Values" class="headerlink" title="5.5.2 Swapping Two Values"></a>5.5.2 Swapping Two Values</h4><h4 id="5-5-3-Supplementary-Comparison-Operators"><a href="#5-5-3-Supplementary-Comparison-Operators" class="headerlink" title="5.5.3 Supplementary Comparison Operators"></a>5.5.3 Supplementary Comparison Operators</h4><h3 id="5-6-Compile-Time-Fractional-Arithmetic-with-Class-ratio-lt-gt"><a href="#5-6-Compile-Time-Fractional-Arithmetic-with-Class-ratio-lt-gt" class="headerlink" title="5.6 Compile-Time Fractional Arithmetic with Class ratio&lt;&gt;"></a>5.6 Compile-Time Fractional Arithmetic with Class ratio&lt;&gt;</h3><pre><code>namespace std {
    template &lt;intmax_t N, intmax_t D = 1&gt;
    class ratio {
    public:
        typedef ratio&lt;num,den&gt; type;
        static constexpr intmax_t num;
        static constexpr intmax_t den;
    };
}
</code></pre><h3 id="5-7-Clocks-and-Timers"><a href="#5-7-Clocks-and-Timers" class="headerlink" title="5.7 Clocks and Timers"></a>5.7 Clocks and Timers</h3><p>C++ standard library provides the basic C and POSIX interfaces to deal with calendar time.<br><img src="https://github.com/israel-Liu/theForger/raw/master/images/ClocksAndTime.png" alt=""></p>
<h4 id="5-7-1-Overview-of-the-Chrono-Library"><a href="#5-7-1-Overview-of-the-Chrono-Library" class="headerlink" title="5.7.1 Overview of the Chrono Library"></a>5.7.1 Overview of the Chrono Library</h4><pre><code>template &lt;typename V, typename R&gt;
    ostream&amp; operator &lt;&lt; (ostream&amp; s, const chrono::duration&lt;V,R&gt;&amp; d)
    {
        s &lt;&lt; &quot;[&quot; &lt;&lt; d.count() &lt;&lt; &quot; of &quot; &lt;&lt; R::num &lt;&lt; &quot;/&quot; &lt;&lt; R::den &lt;&lt; &quot;]&quot;;
        return s;
    }
</code></pre><h4 id="5-7-3-Clocks-and-Timepoints"><a href="#5-7-3-Clocks-and-Timepoints" class="headerlink" title="5.7.3 Clocks and Timepoints"></a>5.7.3 Clocks and Timepoints</h4><p>系统时间调整？原点坐标调整吗，3种时钟还是有点没理解。各种定义比 Unicode 还难理解。<br>UNIX epoch, January 1, 1970 ？ universal time (UTC) ？ 00:00 in Greenwich, UK. ？summertime ？</p>
<h4 id="5-7-4-Date-and-Time-Functions-by-C-and-POSIX"><a href="#5-7-4-Date-and-Time-Functions-by-C-and-POSIX" class="headerlink" title="5.7.4 Date and Time Functions by C and POSIX"></a>5.7.4 Date and Time Functions by C and POSIX</h4><p>time_t usually is just the number of seconds since the UNIX epoch, which is January 1, 1970.</p>
<h4 id="5-7-5-Blocking-with-Timers"><a href="#5-7-5-Blocking-with-Timers" class="headerlink" title="5.7.5 Blocking with Timers"></a>5.7.5 Blocking with Timers</h4><p>计时器时间并不靠谱，包括一些没计算的耗时，还可能根据系统时间调整而变化。</p>
<h3 id="5-8-Header-Files-and"><a href="#5-8-Header-Files-and" class="headerlink" title="5.8 Header Files , , and "></a>5.8 Header Files <cstddef>, <cstdlib>, and <cstring></cstring></cstdlib></cstddef></h3><p>主要就是C里面一些重要的东西在C++里的定义</p>
<h4 id="5-8-2-Definitions-in"><a href="#5-8-2-Definitions-in" class="headerlink" title="5.8.2 Definitions in "></a>5.8.2 Definitions in <cstdlib></cstdlib></h4><pre><code>...
</code></pre><h2 id="Chapter-6-The-Standard-Template-Library"><a href="#Chapter-6-The-Standard-Template-Library" class="headerlink" title="Chapter 6 The Standard Template Library"></a>Chapter 6 The Standard Template Library</h2><h3 id="6-1-STL-Components"><a href="#6-1-STL-Components" class="headerlink" title="6.1 STL Components"></a>6.1 STL Components</h3><h3 id="6-2-Containers"><a href="#6-2-Containers" class="headerlink" title="6.2 Containers"></a>6.2 Containers</h3><h4 id="6-2-1-Sequence-Containers"><a href="#6-2-1-Sequence-Containers" class="headerlink" title="6.2.1 Sequence Containers"></a>6.2.1 Sequence Containers</h4><h4 id="6-2-2-Associative-Containers"><a href="#6-2-2-Associative-Containers" class="headerlink" title="6.2.2 Associative Containers"></a>6.2.2 Associative Containers</h4><h4 id="6-2-4-Associative-Arrays"><a href="#6-2-4-Associative-Arrays" class="headerlink" title="6.2.4 Associative Arrays"></a>6.2.4 Associative Arrays</h4><h4 id="6-2-5-Other-Containers"><a href="#6-2-5-Other-Containers" class="headerlink" title="6.2.5 Other Containers"></a>6.2.5 Other Containers</h4><h4 id="6-2-6-Container-Adapters"><a href="#6-2-6-Container-Adapters" class="headerlink" title="6.2.6 Container Adapters"></a>6.2.6 Container Adapters</h4><h3 id="6-3-Iterators"><a href="#6-3-Iterators" class="headerlink" title="6.3 Iterators"></a>6.3 Iterators</h3><p>Thus,<br>    for (type elem : coll) {<br>        …<br>    }<br>is interpreted as<br>    for (auto pos=coll.begin(), end=coll.end(); pos!=end; ++pos) {<br>        type elem = *pos;<br>        …<br>    }</p>
<h4 id="6-3-1-Further-Examples-of-Using-Associative-and-Unordered-Containers"><a href="#6-3-1-Further-Examples-of-Using-Associative-and-Unordered-Containers" class="headerlink" title="6.3.1 Further Examples of Using Associative and Unordered Containers"></a>6.3.1 Further Examples of Using Associative and Unordered Containers</h4><h4 id="6-3-2-Iterator-Categories"><a href="#6-3-2-Iterator-Categories" class="headerlink" title="6.3.2 Iterator Categories"></a>6.3.2 Iterator Categories</h4><h3 id="6-4-Algorithms"><a href="#6-4-Algorithms" class="headerlink" title="6.4 Algorithms"></a>6.4 Algorithms</h3><h4 id="6-4-1-Ranges"><a href="#6-4-1-Ranges" class="headerlink" title="6.4.1 Ranges"></a>6.4.1 Ranges</h4><p>要保证区间的有效性，防止结尾区间大于开始区间。</p>
<h4 id="6-4-2-Handling-Multiple-Ranges"><a href="#6-4-2-Handling-Multiple-Ranges" class="headerlink" title="6.4.2 Handling Multiple Ranges"></a>6.4.2 Handling Multiple Ranges</h4><h3 id="6-5-Iterator-Adapters"><a href="#6-5-Iterator-Adapters" class="headerlink" title="6.5 Iterator Adapters"></a>6.5 Iterator Adapters</h3><h4 id="6-5-1-Insert-Iterators"><a href="#6-5-1-Insert-Iterators" class="headerlink" title="6.5.1 Insert Iterators"></a>6.5.1 Insert Iterators</h4><p>分别使用了成员函数所以要求提供了相应的成员函数才可以使用。back_inserter –&gt; push_back(val)</p>
<h4 id="6-5-2-Stream-Iterators"><a href="#6-5-2-Stream-Iterators" class="headerlink" title="6.5.2 Stream Iterators"></a>6.5.2 Stream Iterators</h4><h4 id="6-5-3-Reverse-Iterators"><a href="#6-5-3-Reverse-Iterators" class="headerlink" title="6.5.3 Reverse Iterators"></a>6.5.3 Reverse Iterators</h4><p>Create reverse iterators via their member functions rbegin() and rend().</p>
<h4 id="6-5-4-Move-Iterators"><a href="#6-5-4-Move-Iterators" class="headerlink" title="6.5.4 Move Iterators"></a>6.5.4 Move Iterators</h4><h3 id="6-6-User-Defined-Generic-Functions"><a href="#6-6-User-Defined-Generic-Functions" class="headerlink" title="6.6 User-Defined Generic Functions"></a>6.6 User-Defined Generic Functions</h3><h3 id="6-7-Manipulating-Algorithms"><a href="#6-7-Manipulating-Algorithms" class="headerlink" title="6.7 Manipulating Algorithms"></a>6.7 Manipulating Algorithms</h3><p>These aspects are surprising and show the price of the STL concept that separates containers and algorithms with great flexibility.</p>
<h4 id="6-7-1-“Removing”-Elements"><a href="#6-7-1-“Removing”-Elements" class="headerlink" title="6.7.1 “Removing” Elements"></a>6.7.1 “Removing” Elements</h4><p>迭代器不知道他们的容器. 使用迭代器的算法不能访问容器的成员函数。不能真正erase元素。</p>
<h4 id="6-7-2-Manipulating-Associative-and-Unordered-Containers"><a href="#6-7-2-Manipulating-Associative-and-Unordered-Containers" class="headerlink" title="6.7.2 Manipulating Associative and Unordered Containers"></a>6.7.2 Manipulating Associative and Unordered Containers</h4><p>使用提供的成员函数操作元素。</p>
<h4 id="6-7-3-Algorithms-versus-Member-Functions"><a href="#6-7-3-Algorithms-versus-Member-Functions" class="headerlink" title="6.7.3 Algorithms versus Member Functions"></a>6.7.3 Algorithms versus Member Functions</h4><p>如果存在成员函数比通用算法效率更高更准确使用成员函数代替算法。</p>
<h3 id="6-8-Functions-as-Algorithm-Arguments"><a href="#6-8-Functions-as-Algorithm-Arguments" class="headerlink" title="6.8 Functions as Algorithm Arguments"></a>6.8 Functions as Algorithm Arguments</h3><h4 id="6-8-1-Using-Functions-as-Algorithm-Arguments"><a href="#6-8-1-Using-Functions-as-Algorithm-Arguments" class="headerlink" title="6.8.1 Using Functions as Algorithm Arguments"></a>6.8.1 Using Functions as Algorithm Arguments</h4><h4 id="6-8-2-Predicates"><a href="#6-8-2-Predicates" class="headerlink" title="6.8.2 Predicates"></a>6.8.2 Predicates</h4><p>They should always yield the same result for the same value.</p>
<h3 id="6-9-Using-Lambdas"><a href="#6-9-Using-Lambdas" class="headerlink" title="6.9 Using Lambdas"></a>6.9 Using Lambdas</h3><p>不能保存状态，必须在外部定义，在内部捕捉引用。函数对象可以在内部保存状态，在不同地方使用。</p>
<h3 id="6-10-Function-Objects"><a href="#6-10-Function-Objects" class="headerlink" title="6.10 Function Objects"></a>6.10 Function Objects</h3><h4 id="6-10-1-Definition-of-Function-Objects"><a href="#6-10-1-Definition-of-Function-Objects" class="headerlink" title="6.10.1 Definition of Function Objects"></a>6.10.1 Definition of Function Objects</h4><p>Rarely are things not possible in C++.</p>
<h4 id="6-10-2-Predefined-Function-Objects"><a href="#6-10-2-Predefined-Function-Objects" class="headerlink" title="6.10.2 Predefined Function Objects"></a>6.10.2 Predefined Function Objects</h4><p>用于set等构造函数排序方式，用在算法中。</p>
<h4 id="6-10-3-Binders"><a href="#6-10-3-Binders" class="headerlink" title="6.10.3 Binders"></a>6.10.3 Binders</h4><p>也叫做函数适配器，通过低级函数对象组成高级函数对象。</p>
<h3 id="6-11-Container-Elements"><a href="#6-11-Container-Elements" class="headerlink" title="6.11 Container Elements"></a>6.11 Container Elements</h3><h4 id="6-11-1-Requirements-for-Container-Elements"><a href="#6-11-1-Requirements-for-Container-Elements" class="headerlink" title="6.11.1 Requirements for Container Elements"></a>6.11.1 Requirements for Container Elements</h4><p>自定义对象作为容器元素的时候需要满足这些条件，例如提供 operator &lt;</p>
<h4 id="6-11-2-Value-Semantics-or-Reference-Semantics"><a href="#6-11-2-Value-Semantics-or-Reference-Semantics" class="headerlink" title="6.11.2 Value Semantics or Reference Semantics"></a>6.11.2 Value Semantics or Reference Semantics</h4><p>STL容器提供值语义，放入容器中的是原始值的副本。可以通过其它方式实现引用语义，比如使用智能指针或者std::reference_wrapper&lt;&gt;</p>
<h4 id="6-12-Errors-and-Exceptions-inside-the-STL"><a href="#6-12-Errors-and-Exceptions-inside-the-STL" class="headerlink" title="6.12 Errors and Exceptions inside the STL"></a>6.12 Errors and Exceptions inside the STL</h4><h4 id="6-12-1-Error-Handling"><a href="#6-12-1-Error-Handling" class="headerlink" title="6.12.1 Error Handling"></a>6.12.1 Error Handling</h4><p>可以使用安全版本的STL库。</p>
<h4 id="6-12-2-Exception-Handling"><a href="#6-12-2-Exception-Handling" class="headerlink" title="6.12.2 Exception Handling"></a>6.12.2 Exception Handling</h4><p>STL提供了一些保证，在析构函数不抛出异常的情况，很多操作要么成功要么没有影响，出错不抛出异常。</p>
<h3 id="6-13-Extending-the-STL"><a href="#6-13-Extending-the-STL" class="headerlink" title="6.13 Extending the STL"></a>6.13 Extending the STL</h3><h4 id="6-13-1-Integrating-Additional-Types"><a href="#6-13-1-Integrating-Additional-Types" class="headerlink" title="6.13.1 Integrating Additional Types"></a>6.13.1 Integrating Additional Types</h4><h4 id="6-13-2-Deriving-from-STL-Types"><a href="#6-13-2-Deriving-from-STL-Types" class="headerlink" title="6.13.2 Deriving from STL Types"></a>6.13.2 Deriving from STL Types</h4><p>出于性能原因STL类没有提供虚函数，所以不能通过继承提供多态性，可以在内部使用STL类来定义新类。</p>
<h2 id="Chapter-7-STL-Containers"><a href="#Chapter-7-STL-Containers" class="headerlink" title="Chapter 7 STL Containers"></a>Chapter 7 STL Containers</h2><h3 id="7-1-Common-Container-Abilities-and-Operations"><a href="#7-1-Common-Container-Abilities-and-Operations" class="headerlink" title="7.1 Common Container Abilities and Operations"></a>7.1 Common Container Abilities and Operations</h3><h4 id="7-1-1-Container-Abilities"><a href="#7-1-1-Container-Abilities" class="headerlink" title="7.1.1 Container Abilities"></a>7.1.1 Container Abilities</h4><p>提供值语义，保证在不更改的前提下多次访问结果相同，不跑出异常需要调用者满足调用要求。</p>
<h4 id="7-1-2-Container-Operations"><a href="#7-1-2-Container-Operations" class="headerlink" title="7.1.2 Container Operations"></a>7.1.2 Container Operations</h4><p>() 和 = 构造有啥区别？<br>    // move all elements of the list into a vector<br>    std::vector<a href="std::string" target="_blank" rel="noopener">std::string</a> c(std::make_move_iterator(l.begin()), std::make_move_iterator(l.end()));</p>
<h4 id="7-1-3-Container-Types"><a href="#7-1-3-Container-Types" class="headerlink" title="7.1.3 Container Types"></a>7.1.3 Container Types</h4><p>使用 typedef 和 typename 定义了一些类型 </p>
<h3 id="7-2-Arrays"><a href="#7-2-Arrays" class="headerlink" title="7.2 Arrays"></a>7.2 Arrays</h3><h4 id="7-2-1-Abilities-of-Arrays"><a href="#7-2-1-Abilities-of-Arrays" class="headerlink" title="7.2.1 Abilities of Arrays"></a>7.2.1 Abilities of Arrays</h4><p>So, iterators and references refer to the same container but different elements afterward. 这点和其它容器不同。</p>
<h4 id="7-2-2-Array-Operations"><a href="#7-2-2-Array-Operations" class="headerlink" title="7.2.2 Array Operations"></a>7.2.2 Array Operations</h4><h4 id="7-2-3-Using-arrays-as-C-Style-Arrays"><a href="#7-2-3-Using-arrays-as-C-Style-Arrays" class="headerlink" title="7.2.3 Using arrays as C-Style Arrays"></a>7.2.3 Using arrays as C-Style Arrays</h4><p>Use data() where the ordinary C-style interface is required.</p>
<h4 id="7-2-4-Exception-Handling"><a href="#7-2-4-Exception-Handling" class="headerlink" title="7.2.4 Exception Handling"></a>7.2.4 Exception Handling</h4><h4 id="7-2-5-Tuple-Interface"><a href="#7-2-5-Tuple-Interface" class="headerlink" title="7.2.5 Tuple Interface"></a>7.2.5 Tuple Interface</h4><pre><code>typedef std::array&lt;std::string,5&gt; FiveStrings;
FiveStrings a = { &quot;hello&quot;, &quot;nico&quot;, &quot;how&quot;, &quot;are&quot;, &quot;you&quot; };
std::tuple_size&lt;FiveStrings&gt;::value // yields 5
std::tuple_element&lt;1,FiveStrings&gt;::type // yields std::string
std::get&lt;1&gt;(a) // yields std::string(&quot;nico&quot;)
</code></pre><h4 id="7-2-6-Examples-of-Using-Arrays"><a href="#7-2-6-Examples-of-Using-Arrays" class="headerlink" title="7.2.6 Examples of Using Arrays"></a>7.2.6 Examples of Using Arrays</h4><h3 id="7-3-Vectors"><a href="#7-3-Vectors" class="headerlink" title="7.3 Vectors"></a>7.3 Vectors</h3><p>使用 reserve() 成员函数分配大小，避免复杂类型初始化影响性能。</p>
<h4 id="7-3-1-Abilities-of-Vectors"><a href="#7-3-1-Abilities-of-Vectors" class="headerlink" title="7.3.1 Abilities of Vectors"></a>7.3.1 Abilities of Vectors</h4><p>std::vector<t>(v).swap(v); 缩小容器后iter有效，shrink_to_fit()(C++11)缩小容器大小后iter无效。</t></p>
<h4 id="7-3-2-Vector-Operations"><a href="#7-3-2-Vector-Operations" class="headerlink" title="7.3.2 Vector Operations"></a>7.3.2 Vector Operations</h4><p>使用成员函数 at() 访问元素有范围检查，会抛出 out_of_range 异常。</p>
<h4 id="7-3-3-Using-Vectors-as-C-Style-Arrays"><a href="#7-3-3-Using-Vectors-as-C-Style-Arrays" class="headerlink" title="7.3.3 Using Vectors as C-Style Arrays"></a>7.3.3 Using Vectors as C-Style Arrays</h4><h4 id="7-3-4-Exception-Handling"><a href="#7-3-4-Exception-Handling" class="headerlink" title="7.3.4 Exception Handling"></a>7.3.4 Exception Handling</h4><h4 id="7-3-5-Examples-of-Using-Vectors"><a href="#7-3-5-Examples-of-Using-Vectors" class="headerlink" title="7.3.5 Examples of Using Vectors"></a>7.3.5 Examples of Using Vectors</h4><p>一般实现是默认申请 2k 空间，如果不够用翻倍。</p>
<h4 id="7-3-6-Class-vector"><a href="#7-3-6-Class-vector" class="headerlink" title="7.3.6 Class vector"></a>7.3.6 Class vector<bool></bool></h4><p>vector<bool> 是动态调整的 bit 数组，如果你想使用固定大小的 bit 数组。使用 bitset。</bool></p>
<pre><code>namespace std {
    template &lt;typename Allocator&gt; class vector&lt;bool,Allocator&gt; {
        public:
            // auxiliary proxy type for element modifications:
            class reference {
                ...
                public:
                    reference&amp; operator= (const bool) noexcept; // assignments
                    reference&amp; operator= (const reference&amp;) noexcept;
                    operator bool() const noexcept; // automatic type conversion to bool
                    void flip() noexcept; // bit complement
            };
            ...
            // operations for element access return reference proxy instead of bool:
            reference operator[](size_type idx);
            reference at(size_type idx);
            reference front();
            reference back();
            ...
    };
}
</code></pre><h4 id="7-4-Deques"><a href="#7-4-Deques" class="headerlink" title="7.4 Deques"></a>7.4 Deques</h4><p>Deque is typically implemented as a bunch of individual blocks, 第一个和最后一个增长方向相反。</p>
<h4 id="7-4-1-Abilities-of-Deques"><a href="#7-4-1-Abilities-of-Deques" class="headerlink" title="7.4.1 Abilities of Deques"></a>7.4.1 Abilities of Deques</h4><h4 id="7-4-2-Deque-Operations"><a href="#7-4-2-Deque-Operations" class="headerlink" title="7.4.2 Deque Operations"></a>7.4.2 Deque Operations</h4><h4 id="7-4-3-Exception-Handling"><a href="#7-4-3-Exception-Handling" class="headerlink" title="7.4.3 Exception Handling"></a>7.4.3 Exception Handling</h4><h4 id="7-4-4-Examples-of-Using-Deques"><a href="#7-4-4-Examples-of-Using-Deques" class="headerlink" title="7.4.4 Examples of Using Deques"></a>7.4.4 Examples of Using Deques</h4><h3 id="7-5-Lists"><a href="#7-5-Lists" class="headerlink" title="7.5 Lists"></a>7.5 Lists</h3><p>C++ standard library does not specify the kind of the implementation, but it follows from the list’s name, constraints, and specifications.</p>
<h4 id="7-5-1-Abilities-of-Lists"><a href="#7-5-1-Abilities-of-Lists" class="headerlink" title="7.5.1 Abilities of Lists"></a>7.5.1 Abilities of Lists</h4><h4 id="7-5-2-List-Operations"><a href="#7-5-2-List-Operations" class="headerlink" title="7.5.2 List Operations"></a>7.5.2 List Operations</h4><p>两个相同  list 之间直接操作内部指针，合并什么的非常快。</p>
<h4 id="7-5-3-Exception-Handling"><a href="#7-5-3-Exception-Handling" class="headerlink" title="7.5.3 Exception Handling"></a>7.5.3 Exception Handling</h4><h4 id="7-5-4-Examples-of-Using-Lists"><a href="#7-5-4-Examples-of-Using-Lists" class="headerlink" title="7.5.4 Examples of Using Lists"></a>7.5.4 Examples of Using Lists</h4><h3 id="7-6-Forward-Lists"><a href="#7-6-Forward-Lists" class="headerlink" title="7.6 Forward Lists"></a>7.6 Forward Lists</h3><h4 id="7-6-1-Abilities-of-Forward-Lists"><a href="#7-6-1-Abilities-of-Forward-Lists" class="headerlink" title="7.6.1 Abilities of Forward Lists"></a>7.6.1 Abilities of Forward Lists</h4><p>_after, 后入。</p>
<h4 id="7-6-2-Forward-List-Operations"><a href="#7-6-2-Forward-List-Operations" class="headerlink" title="7.6.2 Forward List Operations"></a>7.6.2 Forward List Operations</h4><h4 id="7-6-3-Exception-Handling"><a href="#7-6-3-Exception-Handling" class="headerlink" title="7.6.3 Exception Handling"></a>7.6.3 Exception Handling</h4><h4 id="7-6-4-Examples-of-Using-Forward-Lists"><a href="#7-6-4-Examples-of-Using-Forward-Lists" class="headerlink" title="7.6.4 Examples of Using Forward Lists"></a>7.6.4 Examples of Using Forward Lists</h4><h3 id="7-7-Sets-and-Multisets"><a href="#7-7-Sets-and-Multisets" class="headerlink" title="7.7 Sets and Multisets"></a>7.7 Sets and Multisets</h3><p>各种数学准则用于排序。</p>
<h4 id="7-7-1-Abilities-of-Sets-and-Multisets"><a href="#7-7-1-Abilities-of-Sets-and-Multisets" class="headerlink" title="7.7.1 Abilities of Sets and Multisets"></a>7.7.1 Abilities of Sets and Multisets</h4><p>不可以修改value，因为value就是key有顺序，需要remove然后insert。</p>
<h4 id="7-7-2-Set-and-Multiset-Operations"><a href="#7-7-2-Set-and-Multiset-Operations" class="headerlink" title="7.7.2 Set and Multiset Operations"></a>7.7.2 Set and Multiset Operations</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">c.lower_bound(val) <span class="comment">// 返回第一个 &gt;= val 值的位置，val 插入的第一个位置</span></span><br><span class="line">c.upper_bound(val) <span class="comment">// 返回第一个 &gt; val 值的位置，val 插入的最后一个位置 [pos_val, end) 开区间</span></span><br><span class="line">c.equal_range(val) <span class="comment">// [begin_val, end_val)</span></span><br><span class="line"></span><br><span class="line">c.emplace(args...) <span class="comment">// args 用来初始化 set 里面成员</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;Elem&gt; coll;</span><br><span class="line">...</span><br><span class="line">/ remove first element with passed value</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;Elem&gt;::iterator pos;</span><br><span class="line">pos = coll.find(value);</span><br><span class="line"><span class="keyword">if</span> (pos != coll.end()) &#123;</span><br><span class="line">	coll.erase(pos);              <span class="comment">// set直接使用 coll.erase(value) multiset 使用单值的效率低。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-7-3-Exception-Handling"><a href="#7-7-3-Exception-Handling" class="headerlink" title="7.7.3 Exception Handling"></a>7.7.3 Exception Handling</h4><h4 id="7-7-4-Examples-of-Using-Sets-and-Multisets"><a href="#7-7-4-Examples-of-Using-Sets-and-Multisets" class="headerlink" title="7.7.4 Examples of Using Sets and Multisets"></a>7.7.4 Examples of Using Sets and Multisets</h4><h4 id="7-7-5-Example-of-Specifying-the-Sorting-Criterion-at-Runtime"><a href="#7-7-5-Example-of-Specifying-the-Sorting-Criterion-at-Runtime" class="headerlink" title="7.7.5 Example of Specifying the Sorting Criterion at Runtime"></a>7.7.5 Example of Specifying the Sorting Criterion at Runtime</h4><h3 id="7-8-Maps-and-Multimaps"><a href="#7-8-Maps-and-Multimaps" class="headerlink" title="7.8 Maps and Multimaps"></a>7.8 Maps and Multimaps</h3><h4 id="7-8-1-Abilities-of-Maps-and-Multimaps"><a href="#7-8-1-Abilities-of-Maps-and-Multimaps" class="headerlink" title="7.8.1 Abilities of Maps and Multimaps"></a>7.8.1 Abilities of Maps and Multimaps</h4><p>不可以直接修改key但是可以修改value。</p>
<h4 id="7-8-2-Map-and-Multimap-Operations"><a href="#7-8-2-Map-and-Multimap-Operations" class="headerlink" title="7.8.2 Map and Multimap Operations"></a>7.8.2 Map and Multimap Operations</h4><p>You can define the sorting criterion in two ways, 模板参数(sorting criterion is part of the type)编译期期确定和构造函数参数运行期确定。</p>
<pre><code>std::multimap&lt;std::string,float&gt; coll;
...
// do something with all elements having a certain value
std::multimap&lt;std::string,float&gt;::iterator pos;
for (pos = coll.begin(); pos != coll.end(); ++pos) {
    if (pos-&gt;second == value) {
        do_something(); // 如果是查询key请使用成员函数效率更高。
    }
}
</code></pre><p>c1.swap(c2) 元素被交换的时候排序标准是否不交换。</p>
<pre><code>std::map&lt;std::string,float&gt; coll;
...
coll.insert(std::map&lt;std::string,float&gt;::value_type(&quot;otto&quot;, 22.3));
or
coll.insert(decltype(coll)::value_type(&quot;otto&quot;,22.3));


std::map&lt;std::string,std::complex&lt;float&gt;&gt; m;
m.emplace(std::piecewise_construct, // pass tuple elements as arguments
std::make_tuple(&quot;hello&quot;), // elements for the key
std::make_tuple(3.4,7.8)); // elements for the value

// remove all elements having a certain value // before C++11
for (pos = coll.begin(); pos != coll.end(); ) {
    if (pos-&gt;second == value) {
        coll.erase(pos++);
    }
    else {
        ++pos;
    }
}
</code></pre><h4 id="7-8-3-Using-Maps-as-Associative-Arrays"><a href="#7-8-3-Using-Maps-as-Associative-Arrays" class="headerlink" title="7.8.3 Using Maps as Associative Arrays"></a>7.8.3 Using Maps as Associative Arrays</h4><p>一定要清醒每次操作都做了哪些看不到的事情，包括调用值的构造函数。std::cout &lt;&lt; coll[“ottto”]; // 同样会发生插入和赋初值对于不存在的key。</p>
<h4 id="7-8-4-Exception-Handling"><a href="#7-8-4-Exception-Handling" class="headerlink" title="7.8.4 Exception Handling"></a>7.8.4 Exception Handling</h4><h4 id="7-8-5-Examples-of-Using-Maps-and-Multimaps"><a href="#7-8-5-Examples-of-Using-Maps-and-Multimaps" class="headerlink" title="7.8.5 Examples of Using Maps and Multimaps"></a>7.8.5 Examples of Using Maps and Multimaps</h4><p>查询key用成员函数，查询value用算法。使用value_type声明变量。</p>
<h4 id="7-8-6-Example-with-Maps-Strings-and-Sorting-Criterion-at-Runtime"><a href="#7-8-6-Example-with-Maps-Strings-and-Sorting-Criterion-at-Runtime" class="headerlink" title="7.8.6 Example with Maps, Strings, and Sorting Criterion at Runtime"></a>7.8.6 Example with Maps, Strings, and Sorting Criterion at Runtime</h4><h3 id="7-9-Unordered-Containers"><a href="#7-9-Unordered-Containers" class="headerlink" title="7.9 Unordered Containers"></a>7.9 Unordered Containers</h3><h4 id="7-9-1-Abilities-of-Unordered-Containers"><a href="#7-9-1-Abilities-of-Unordered-Containers" class="headerlink" title="7.9.1 Abilities of Unordered Containers"></a>7.9.1 Abilities of Unordered Containers</h4><p>重hash是不是就是因为当前出现了元素冲突。</p>
<h4 id="7-9-2-Creating-and-Controlling-Unordered-Containers"><a href="#7-9-2-Creating-and-Controlling-Unordered-Containers" class="headerlink" title="7.9.2 Creating and Controlling Unordered Containers"></a>7.9.2 Creating and Controlling Unordered Containers</h4><pre><code>std::size_t customer_hash_func (const Customer&amp; c)
{
    return ...
};
std::unordered_set&lt;Customer,std::size_t(*)(const Customer&amp;)&gt;
custset(20,customer_hash_func);
</code></pre><h4 id="7-9-3-Other-Operations-for-Unordered-Containers"><a href="#7-9-3-Other-Operations-for-Unordered-Containers" class="headerlink" title="7.9.3 Other Operations for Unordered Containers"></a>7.9.3 Other Operations for Unordered Containers</h4><p>当发生重新hash的时候迭代器无效但是对元素的引用还是有效的，可能是因为迭代器和buckets有关系。</p>
<h4 id="7-9-4-The-Bucket-Interface"><a href="#7-9-4-The-Bucket-Interface" class="headerlink" title="7.9.4 The Bucket Interface"></a>7.9.4 The Bucket Interface</h4><p>了解内部结构，看啥函数都很清晰。</p>
<h4 id="7-9-5-Using-Unordered-Maps-as-Associative-Arrays"><a href="#7-9-5-Using-Unordered-Maps-as-Associative-Arrays" class="headerlink" title="7.9.5 Using Unordered Maps as Associative Arrays"></a>7.9.5 Using Unordered Maps as Associative Arrays</h4><h4 id="7-9-6-Exception-Handling"><a href="#7-9-6-Exception-Handling" class="headerlink" title="7.9.6 Exception Handling"></a>7.9.6 Exception Handling</h4><p>所有不抛出异常的行为，都依赖于所使用的函数不抛出异常。</p>
<h4 id="7-9-7-Examples-of-Using-Unordered-Containers"><a href="#7-9-7-Examples-of-Using-Unordered-Containers" class="headerlink" title="7.9.7 Examples of Using Unordered Containers"></a>7.9.7 Examples of Using Unordered Containers</h4><p>重新hash保证等价元素相对位置，但是插入顺序不一定是等于相对位置。</p>
<h3 id="7-10-Other-STL-Containers"><a href="#7-10-Other-STL-Containers" class="headerlink" title="7.10 Other STL Containers"></a>7.10 Other STL Containers</h3><p>侵入性提供自己的容器包含可访问内部元素。非侵入性提供访问迭代器访问容器。通过包装现有容器实现新容器。</p>
<h4 id="7-10-1-Strings-as-STL-Containers"><a href="#7-10-1-Strings-as-STL-Containers" class="headerlink" title="7.10.1 Strings as STL Containers"></a>7.10.1 Strings as STL Containers</h4><p>可以整个string处理，也可以单个处理里面的字符</p>
<h4 id="7-10-2-Ordinary-C-Style-Arrays-as-STL-Containers"><a href="#7-10-2-Ordinary-C-Style-Arrays-as-STL-Containers" class="headerlink" title="7.10.2 Ordinary C-Style Arrays as STL Containers"></a>7.10.2 Ordinary C-Style Arrays as STL Containers</h4><p>只能使用非侵入式和包装器方式。Using a global begin() and end() for ordinary C-style arrays.在C++11前使用raw pointers。</p>
<h3 id="7-11-Implementing-Reference-Semantics"><a href="#7-11-Implementing-Reference-Semantics" class="headerlink" title="7.11 Implementing Reference Semantics"></a>7.11 Implementing Reference Semantics</h3><p>智能指针和引用包装器。</p>
<h3 id="7-12-When-to-Use-Which-Container"><a href="#7-12-When-to-Use-Which-Container" class="headerlink" title="7.12 When to Use Which Container"></a>7.12 When to Use Which Container</h3><p>多种选择多多尝试，有时候不同系统效率不同。</p>
<h2 id="Chapter-8-STL-Container-Members-in-Detail"><a href="#Chapter-8-STL-Container-Members-in-Detail" class="headerlink" title="Chapter 8 STL Container Members in Detail"></a>Chapter 8 STL Container Members in Detail</h2><h3 id="8-1-Type-Definitions"><a href="#8-1-Type-Definitions" class="headerlink" title="8.1 Type Definitions"></a>8.1 Type Definitions</h3><p>container::difference_type 突然忘记这个是干嘛的来着。</p>
<h3 id="8-2-Create-Copy-and-Destroy-Operations"><a href="#8-2-Create-Copy-and-Destroy-Operations" class="headerlink" title="8.2 Create, Copy, and Destroy Operations"></a>8.2 Create, Copy, and Destroy Operations</h3><p>析构函数• Removes all elements and frees the memory. • Calls the destructor for every element.</p>
<h3 id="8-3-Nonmodifying-Operations"><a href="#8-3-Nonmodifying-Operations" class="headerlink" title="8.3 Nonmodifying Operations"></a>8.3 Nonmodifying Operations</h3><h4 id="8-3-1-Size-Operations"><a href="#8-3-1-Size-Operations" class="headerlink" title="8.3.1 Size Operations"></a>8.3.1 Size Operations</h4><h4 id="8-3-2-Comparison-Operations"><a href="#8-3-2-Comparison-Operations" class="headerlink" title="8.3.2 Comparison Operations"></a>8.3.2 Comparison Operations</h4><h4 id="8-3-3-Nonmodifying-Operations-for-Associative-and-Unordered-Containers"><a href="#8-3-3-Nonmodifying-Operations-for-Associative-and-Unordered-Containers" class="headerlink" title="8.3.3 Nonmodifying Operations for Associative and Unordered Containers"></a>8.3.3 Nonmodifying Operations for Associative and Unordered Containers</h4><h3 id="8-4-Assignments"><a href="#8-4-Assignments" class="headerlink" title="8.4 Assignments"></a>8.4 Assignments</h3><pre><code>// 可能会调用元素的赋值操作符用于覆盖现有元素，调用构造函数对于新加入元素，调用析构函数对于移除的元素
container&amp; container::operator = (const container&amp; c)
container&amp; container::operator = (container&amp;&amp; c) // 全部覆盖。

container&amp; container::operator = (initializer-list) // 同样调用很多函数
void container::assign (initializer-list)  // 也是全部覆盖

void container::swap (container&amp; c)
void swap (container&amp; c1, container&amp; c2)
• Swap the contents with c or between c1 and c2, respectively.
• Both swap:
– The container’s elements
– Their sorting criterion, equivalence predicate, and hash function object, if any.
The references, pointers, and iterators referring to elements swap their containers, because they
still refer to the same swapped elements afterward.
Iterators and references refer to the same container but different elements afterward.
</code></pre><h3 id="8-5-Direct-Element-Access"><a href="#8-5-Direct-Element-Access" class="headerlink" title="8.5 Direct Element Access"></a>8.5 Direct Element Access</h3><p>T<em> container::data ()  // 返回 C 数组 Provided by array, vector, string.<br>const T</em> container::data () const</p>
<h3 id="8-6-Operations-to-Generate-Iterators"><a href="#8-6-Operations-to-Generate-Iterators" class="headerlink" title="8.6 Operations to Generate Iterators"></a>8.6 Operations to Generate Iterators</h3><h3 id="8-7-Inserting-and-Removing-Elements"><a href="#8-7-Inserting-and-Removing-Elements" class="headerlink" title="8.7 Inserting and Removing Elements"></a>8.7 Inserting and Removing Elements</h3><h4 id="8-7-1-Inserting-Single-Elements"><a href="#8-7-1-Inserting-Single-Elements" class="headerlink" title="8.7.1 Inserting Single Elements"></a>8.7.1 Inserting Single Elements</h4><pre><code>void container::emplace_front (args) // 这个插入在前面还是替换第一个
// 如果是从前面插入，和push_front有啥不同。
</code></pre><h4 id="8-7-2-Inserting-Multiple-Elements"><a href="#8-7-2-Inserting-Multiple-Elements" class="headerlink" title="8.7.2 Inserting Multiple Elements"></a>8.7.2 Inserting Multiple Elements</h4><h4 id="8-7-3-Removing-Elements"><a href="#8-7-3-Removing-Elements" class="headerlink" title="8.7.3 Removing Elements"></a>8.7.3 Removing Elements</h4><h4 id="8-7-4-Resizing"><a href="#8-7-4-Resizing" class="headerlink" title="8.7.4 Resizing"></a>8.7.4 Resizing</h4><h3 id="8-8-Special-Member-Functions-for-Lists-and-Forward-Lists"><a href="#8-8-Special-Member-Functions-for-Lists-and-Forward-Lists" class="headerlink" title="8.8 Special Member Functions for Lists and Forward Lists"></a>8.8 Special Member Functions for Lists and Forward Lists</h3><h4 id="8-8-1-Special-Member-Functions-for-Lists-and-Forward-Lists"><a href="#8-8-1-Special-Member-Functions-for-Lists-and-Forward-Lists" class="headerlink" title="8.8.1 Special Member Functions for Lists (and Forward Lists)"></a>8.8.1 Special Member Functions for Lists (and Forward Lists)</h4><h4 id="8-8-2-Special-Member-Functions-for-Forward-Lists-Only"><a href="#8-8-2-Special-Member-Functions-for-Forward-Lists-Only" class="headerlink" title="8.8.2 Special Member Functions for Forward Lists Only"></a>8.8.2 Special Member Functions for Forward Lists Only</h4><h3 id="8-9-Container-Policy-Interfaces"><a href="#8-9-Container-Policy-Interfaces" class="headerlink" title="8.9 Container Policy Interfaces"></a>8.9 Container Policy Interfaces</h3><h4 id="8-9-1-Nonmodifying-Policy-Functions"><a href="#8-9-1-Nonmodifying-Policy-Functions" class="headerlink" title="8.9.1 Nonmodifying Policy Functions"></a>8.9.1 Nonmodifying Policy Functions</h4><h4 id="8-9-2-Modifying-Policy-Functions"><a href="#8-9-2-Modifying-Policy-Functions" class="headerlink" title="8.9.2 Modifying Policy Functions"></a>8.9.2 Modifying Policy Functions</h4><h4 id="8-9-3-Bucket-Interface-for-Unordered-Containers"><a href="#8-9-3-Bucket-Interface-for-Unordered-Containers" class="headerlink" title="8.9.3 Bucket Interface for Unordered Containers"></a>8.9.3 Bucket Interface for Unordered Containers</h4><p>是否提供了 operator[]</p>
<h3 id="8-10-Allocator-Support"><a href="#8-10-Allocator-Support" class="headerlink" title="8.10 Allocator Support"></a>8.10 Allocator Support</h3><h4 id="8-10-1-Fundamental-Allocator-Members"><a href="#8-10-1-Fundamental-Allocator-Members" class="headerlink" title="8.10.1 Fundamental Allocator Members"></a>8.10.1 Fundamental Allocator Members</h4><h4 id="8-10-2-Constructors-with-Optional-Allocator-Parameters"><a href="#8-10-2-Constructors-with-Optional-Allocator-Parameters" class="headerlink" title="8.10.2 Constructors with Optional Allocator Parameters"></a>8.10.2 Constructors with Optional Allocator Parameters</h4><h2 id="Chapter-9-STL-Iterators"><a href="#Chapter-9-STL-Iterators" class="headerlink" title="Chapter 9 STL Iterators"></a>Chapter 9 STL Iterators</h2><h3 id="9-1-Header-Files-for-Iterators"><a href="#9-1-Header-Files-for-Iterators" class="headerlink" title="9.1 Header Files for Iterators"></a>9.1 Header Files for Iterators</h3><h3 id="9-2-Iterator-Categories"><a href="#9-2-Iterator-Categories" class="headerlink" title="9.2 Iterator Categories"></a>9.2 Iterator Categories</h3><h4 id="9-2-2-Input-Iterators"><a href="#9-2-2-Input-Iterators" class="headerlink" title="9.2.2 Input Iterators"></a>9.2.2 Input Iterators</h4><p>后 pos++ 需要保存临时变量，没有前 ++pos 效率高。</p>
<h4 id="9-2-3-Forward-Iterators"><a href="#9-2-3-Forward-Iterators" class="headerlink" title="9.2.3 Forward Iterators"></a>9.2.3 Forward Iterators</h4><h4 id="9-2-4-Bidirectional-Iterators"><a href="#9-2-4-Bidirectional-Iterators" class="headerlink" title="9.2.4 Bidirectional Iterators"></a>9.2.4 Bidirectional Iterators</h4><h4 id="9-2-5-Random-Access-Iterators"><a href="#9-2-5-Random-Access-Iterators" class="headerlink" title="9.2.5 Random-Access Iterators"></a>9.2.5 Random-Access Iterators</h4><h4 id="9-2-6-The-Increment-and-Decrement-Problem-of-Vector-Iterators"><a href="#9-2-6-The-Increment-and-Decrement-Problem-of-Vector-Iterators" class="headerlink" title="9.2.6 The Increment and Decrement Problem of Vector Iterators"></a>9.2.6 The Increment and Decrement Problem of Vector Iterators</h4><p>当Iterator作为类实现的时候可以使用临时变量，当作为原始指针的时候不可以。</p>
<h3 id="9-3-Auxiliary-Iterator-Functions"><a href="#9-3-Auxiliary-Iterator-Functions" class="headerlink" title="9.3 Auxiliary Iterator Functions"></a>9.3 Auxiliary Iterator Functions</h3><h4 id="9-3-1-advance"><a href="#9-3-1-advance" class="headerlink" title="9.3.1 advance()"></a>9.3.1 advance()</h4><p>按步移动，可以用来跳过某些输入流里面的项。    </p>
<h4 id="9-3-2-next-and-prev"><a href="#9-3-2-next-and-prev" class="headerlink" title="9.3.2 next() and prev()"></a>9.3.2 next() and prev()</h4><h4 id="9-3-3-distance"><a href="#9-3-3-distance" class="headerlink" title="9.3.3 distance()"></a>9.3.3 distance()</h4><h4 id="9-3-4-iter-swap"><a href="#9-3-4-iter-swap" class="headerlink" title="9.3.4 iter_swap()"></a>9.3.4 iter_swap()</h4><h4 id="9-4-Iterator-Adapters"><a href="#9-4-Iterator-Adapters" class="headerlink" title="9.4 Iterator Adapters"></a>9.4 Iterator Adapters</h4><h4 id="9-4-1-Reverse-Iterators"><a href="#9-4-1-Reverse-Iterators" class="headerlink" title="9.4.1 Reverse Iterators"></a>9.4.1 Reverse Iterators</h4><p>物理位置和逻辑位置要分清楚，(开闭区间反向取值也是开闭区间)</p>
<h4 id="9-4-2-Insert-Iterators"><a href="#9-4-2-Insert-Iterators" class="headerlink" title="9.4.2 Insert Iterators"></a>9.4.2 Insert Iterators</h4><h4 id="9-4-3-Stream-Iterators"><a href="#9-4-3-Stream-Iterators" class="headerlink" title="9.4.3 Stream Iterators"></a>9.4.3 Stream Iterators</h4><p>STL定义了输出输出流，又定义了流迭代器，这样算法就可以直接输入出了。</p>
<h4 id="9-4-4-Move-Iterators"><a href="#9-4-4-Move-Iterators" class="headerlink" title="9.4.4 Move Iterators"></a>9.4.4 Move Iterators</h4><h3 id="9-5-Iterator-Traits"><a href="#9-5-Iterator-Traits" class="headerlink" title="9.5 Iterator Traits"></a>9.5 Iterator Traits</h3><pre><code>namespace std {            // 具体怎么用也没看到例子
    template &lt;typename T&gt;
    struct iterator_traits {
        typedef typename T::iterator_category iterator_category;
        typedef typename T::value_type value_type;
        typedef typename T::difference_type difference_type;
        typedef typename T::pointer pointer;
        typedef typename T::reference reference;
    };
}    
</code></pre><h4 id="9-5-1-Writing-Generic-Functions-for-Iterators"><a href="#9-5-1-Writing-Generic-Functions-for-Iterators" class="headerlink" title="9.5.1 Writing Generic Functions for Iterators"></a>9.5.1 Writing Generic Functions for Iterators</h4><p>可以随意写这种代码的时候，STL就理解的差不多了。</p>
<h4 id="9-6-Writing-User-Defined-Iterators"><a href="#9-6-Writing-User-Defined-Iterators" class="headerlink" title="9.6 Writing User-Defined Iterators"></a>9.6 Writing User-Defined Iterators</h4><p>At creation time the iterator stores its container in its container member。</p>
<h2 id="Chapter-10-STL-Function-Objects-and-Using-Lambdas"><a href="#Chapter-10-STL-Function-Objects-and-Using-Lambdas" class="headerlink" title="Chapter 10 STL Function Objects and Using Lambdas"></a>Chapter 10 STL Function Objects and Using Lambdas</h2><h3 id="10-1-The-Concept-of-Function-Objects"><a href="#10-1-The-Concept-of-Function-Objects" class="headerlink" title="10.1 The Concept of Function Objects"></a>10.1 The Concept of Function Objects</h3><h4 id="10-1-1-Function-Objects-as-Sorting-Criteria"><a href="#10-1-1-Function-Objects-as-Sorting-Criteria" class="headerlink" title="10.1.1 Function Objects as Sorting Criteria"></a>10.1.1 Function Objects as Sorting Criteria</h4><h4 id="10-1-2-Function-Objects-with-Internal-State"><a href="#10-1-2-Function-Objects-with-Internal-State" class="headerlink" title="10.1.2 Function Objects with Internal State"></a>10.1.2 Function Objects with Internal State</h4><p>可以同模板构造函数参数来传递引用的函数对象，保持函数对象状态统一。</p>
<h4 id="10-1-3-The-Return-Value-of-for-each"><a href="#10-1-3-The-Return-Value-of-for-each" class="headerlink" title="10.1.3 The Return Value of for_each()"></a>10.1.3 The Return Value of for_each()</h4><h4 id="10-1-4-Predicates-versus-Function-Objects"><a href="#10-1-4-Predicates-versus-Function-Objects" class="headerlink" title="10.1.4 Predicates versus Function Objects"></a>10.1.4 Predicates versus Function Objects</h4><p>A predicate should always be stateless，并且 operator() 返回值可以转换为bool。</p>
<h3 id="10-2-Predefined-Function-Objects-and-Binders"><a href="#10-2-Predefined-Function-Objects-and-Binders" class="headerlink" title="10.2 Predefined Function Objects and Binders"></a>10.2 Predefined Function Objects and Binders</h3><h4 id="10-2-1-Predefined-Function-Objects"><a href="#10-2-1-Predefined-Function-Objects" class="headerlink" title="10.2.1 Predefined Function Objects"></a>10.2.1 Predefined Function Objects</h4><h4 id="10-2-2-Function-Adapters-and-Binders"><a href="#10-2-2-Function-Adapters-and-Binders" class="headerlink" title="10.2.2 Function Adapters and Binders"></a>10.2.2 Function Adapters and Binders</h4><p>std::placeholders::_1 是编译器确定还是运行期间确定，表达式可以用变量表示吗？<br>    map&lt;string,int&gt; coll; // map of int values associated to strings<br>    …<br>    // accumulate all values (member second of the elements)<br>    int sum = accumulate (coll.begin(), coll.end(), 0,<br>                            bind(plus<int>(),<br>                            _1,<br>                            bind(&amp;map&lt;string,int&gt;::value_type::second,<br>                            _2)));</int></p>
<h4 id="10-2-3-User-Defined-Function-Objects-for-Function-Adapters"><a href="#10-2-3-User-Defined-Function-Objects-for-Function-Adapters" class="headerlink" title="10.2.3 User-Defined Function Objects for Function Adapters"></a>10.2.3 User-Defined Function Objects for Function Adapters</h4><h4 id="10-2-4-Deprecated-Function-Adapters"><a href="#10-2-4-Deprecated-Function-Adapters" class="headerlink" title="10.2.4 Deprecated Function Adapters"></a>10.2.4 Deprecated Function Adapters</h4><h3 id="10-3-Using-Lambdas"><a href="#10-3-Using-Lambdas" class="headerlink" title="10.3 Using Lambdas"></a>10.3 Using Lambdas</h3><p>Lambdas are a language feature.</p>
<h4 id="10-3-1-Lambdas-versus-Binders"><a href="#10-3-1-Lambdas-versus-Binders" class="headerlink" title="10.3.1 Lambdas versus Binders"></a>10.3.1 Lambdas versus Binders</h4><p>需要理解好什么时候用那种。Lambdas一般在算法中看起来更直观, Binder 再callback时候用的比较多。</p>
<h4 id="10-3-2-Lambdas-versus-Stateful-Function-Objects"><a href="#10-3-2-Lambdas-versus-Stateful-Function-Objects" class="headerlink" title="10.3.2 Lambdas versus Stateful Function Objects"></a>10.3.2 Lambdas versus Stateful Function Objects</h4><p>非引用捕获为啥是两个状态的lambdas函数，引用捕获的时候就是一个？涉及到状态的时候Lambda可能就比函数对象差点。</p>
<pre><code>remove_if(coll.begin(),coll.end(), // range
[count] (int) mutable { // remove criterion
    return ++count == 3;
});
</code></pre><p><code>`</code></p>
<h4 id="10-3-3-Lambdas-Calling-Global-and-Member-Functions"><a href="#10-3-3-Lambdas-Calling-Global-and-Member-Functions" class="headerlink" title="10.3.3 Lambdas Calling Global and Member Functions"></a>10.3.3 Lambdas Calling Global and Member Functions</h4><p>注意区分捕获的变量，和参数传递的变量。</p>
<h4 id="10-3-4-Lambdas-as-Hash-Function-Sorting-or-Equivalence-Criterion"><a href="#10-3-4-Lambdas-as-Hash-Function-Sorting-or-Equivalence-Criterion" class="headerlink" title="10.3.4 Lambdas as Hash Function, Sorting, or Equivalence Criterion"></a>10.3.4 Lambdas as Hash Function, Sorting, or Equivalence Criterion</h4><p>Note again that you have to use decltype to pass the type of the lambda to the unordered_set because it creates its own instance of them.<br>所以模板构造和构造函数构造对象都提供的模板类，什么时候用，怎么选择.。</p>
<h2 id="Chapter-11-STL-Algorithms"><a href="#Chapter-11-STL-Algorithms" class="headerlink" title="Chapter 11 STL Algorithms"></a>Chapter 11 STL Algorithms</h2><h3 id="11-1-Algorithm-Header-Files"><a href="#11-1-Algorithm-Header-Files" class="headerlink" title="11.1 Algorithm Header Files"></a>11.1 Algorithm Header Files</h3><p>#include <algorithm>一般算法，#include <numeric>数学算法，#include <functional>函数对象。</functional></numeric></algorithm></p>
<h3 id="11-2-Algorithm-Overview"><a href="#11-2-Algorithm-Overview" class="headerlink" title="11.2 Algorithm Overview"></a>11.2 Algorithm Overview</h3><h4 id="11-2-1-A-Brief-Introduction"><a href="#11-2-1-A-Brief-Introduction" class="headerlink" title="11.2.1 A Brief Introduction"></a>11.2.1 A Brief Introduction</h4><h4 id="11-2-2-Classification-of-Algorithms"><a href="#11-2-2-Classification-of-Algorithms" class="headerlink" title="11.2.2 Classification of Algorithms"></a>11.2.2 Classification of Algorithms</h4><p>Nevertheless, to be safe, you should call merge() only for sorted ranges.</p>
<h3 id="11-3-Auxiliary-Functions"><a href="#11-3-Auxiliary-Functions" class="headerlink" title="11.3 Auxiliary Functions"></a>11.3 Auxiliary Functions</h3><h3 id="11-4-The-for-each-Algorithm"><a href="#11-4-The-for-each-Algorithm" class="headerlink" title="11.4 The for_each() Algorithm"></a>11.4 The for_each() Algorithm</h3><h3 id="11-5-Nonmodifying-Algorithms"><a href="#11-5-Nonmodifying-Algorithms" class="headerlink" title="11.5 Nonmodifying Algorithms"></a>11.5 Nonmodifying Algorithms</h3><p>访问元素 without modifying their values or changing their order.</p>
<h4 id="11-5-1-Counting-Elements"><a href="#11-5-1-Counting-Elements" class="headerlink" title="11.5.1 Counting Elements"></a>11.5.1 Counting Elements</h4><h4 id="11-5-2-Minimum-and-Maximum"><a href="#11-5-2-Minimum-and-Maximum" class="headerlink" title="11.5.2 Minimum and Maximum"></a>11.5.2 Minimum and Maximum</h4><h4 id="11-5-3-Searching-Elements"><a href="#11-5-3-Searching-Elements" class="headerlink" title="11.5.3 Searching Elements"></a>11.5.3 Searching Elements</h4><h4 id="11-5-4-Comparing-Ranges"><a href="#11-5-4-Comparing-Ranges" class="headerlink" title="11.5.4 Comparing Ranges"></a>11.5.4 Comparing Ranges</h4><h4 id="11-5-5-Predicates-for-Ranges"><a href="#11-5-5-Predicates-for-Ranges" class="headerlink" title="11.5.5 Predicates for Ranges"></a>11.5.5 Predicates for Ranges</h4><h3 id="11-6-Modifying-Algorithms"><a href="#11-6-Modifying-Algorithms" class="headerlink" title="11.6 Modifying Algorithms"></a>11.6 Modifying Algorithms</h3><h4 id="11-6-1-Copying-Elements"><a href="#11-6-1-Copying-Elements" class="headerlink" title="11.6.1 Copying Elements"></a>11.6.1 Copying Elements</h4><h4 id="11-6-2-Moving-Elements"><a href="#11-6-2-Moving-Elements" class="headerlink" title="11.6.2 Moving Elements"></a>11.6.2 Moving Elements</h4><h4 id="11-6-3-Transforming-and-Combining-Elements"><a href="#11-6-3-Transforming-and-Combining-Elements" class="headerlink" title="11.6.3 Transforming and Combining Elements"></a>11.6.3 Transforming and Combining Elements</h4><h4 id="11-6-4-Swapping-Elements"><a href="#11-6-4-Swapping-Elements" class="headerlink" title="11.6.4 Swapping Elements"></a>11.6.4 Swapping Elements</h4><h4 id="11-6-5-Assigning-New-Values"><a href="#11-6-5-Assigning-New-Values" class="headerlink" title="11.6.5 Assigning New Values"></a>11.6.5 Assigning New Values</h4><h4 id="11-6-6-Replacing-Elements"><a href="#11-6-6-Replacing-Elements" class="headerlink" title="11.6.6 Replacing Elements"></a>11.6.6 Replacing Elements</h4><h3 id="11-7-Removing-Algorithms"><a href="#11-7-Removing-Algorithms" class="headerlink" title="11.7 Removing Algorithms"></a>11.7 Removing Algorithms</h3><h4 id="11-7-1-Removing-Certain-Values"><a href="#11-7-1-Removing-Certain-Values" class="headerlink" title="11.7.1 Removing Certain Values"></a>11.7.1 Removing Certain Values</h4><h4 id="11-7-2-Removing-Duplicates"><a href="#11-7-2-Removing-Duplicates" class="headerlink" title="11.7.2 Removing Duplicates"></a>11.7.2 Removing Duplicates</h4><h3 id="11-8-Mutating-Algorithms"><a href="#11-8-Mutating-Algorithms" class="headerlink" title="11.8 Mutating Algorithms"></a>11.8 Mutating Algorithms</h3><h4 id="11-8-1-Reversing-the-Order-of-Elements"><a href="#11-8-1-Reversing-the-Order-of-Elements" class="headerlink" title="11.8.1 Reversing the Order of Elements"></a>11.8.1 Reversing the Order of Elements</h4><h4 id="11-8-2-Rotating-Elements"><a href="#11-8-2-Rotating-Elements" class="headerlink" title="11.8.2 Rotating Elements"></a>11.8.2 Rotating Elements</h4><h4 id="11-8-3-Permuting-Elements"><a href="#11-8-3-Permuting-Elements" class="headerlink" title="11.8.3 Permuting Elements"></a>11.8.3 Permuting Elements</h4><h4 id="11-8-4-Shuffling-Elements"><a href="#11-8-4-Shuffling-Elements" class="headerlink" title="11.8.4 Shuffling Elements"></a>11.8.4 Shuffling Elements</h4><h4 id="11-8-5-Moving-Elements-to-the-Front"><a href="#11-8-5-Moving-Elements-to-the-Front" class="headerlink" title="11.8.5 Moving Elements to the Front"></a>11.8.5 Moving Elements to the Front</h4><h4 id="11-8-6-Partition-into-Two-Subranges"><a href="#11-8-6-Partition-into-Two-Subranges" class="headerlink" title="11.8.6 Partition into Two Subranges"></a>11.8.6 Partition into Two Subranges</h4><h3 id="11-9-Sorting-Algorithms"><a href="#11-9-Sorting-Algorithms" class="headerlink" title="11.9 Sorting Algorithms"></a>11.9 Sorting Algorithms</h3><h4 id="11-9-1-Sorting-All-Elements"><a href="#11-9-1-Sorting-All-Elements" class="headerlink" title="11.9.1 Sorting All Elements"></a>11.9.1 Sorting All Elements</h4><h4 id="11-9-2-Partial-Sorting"><a href="#11-9-2-Partial-Sorting" class="headerlink" title="11.9.2 Partial Sorting"></a>11.9.2 Partial Sorting</h4><h4 id="11-9-3-Sorting-According-to-the-nth-Element"><a href="#11-9-3-Sorting-According-to-the-nth-Element" class="headerlink" title="11.9.3 Sorting According to the nth Element"></a>11.9.3 Sorting According to the nth Element</h4><h4 id="11-9-4-Heap-Algorithms"><a href="#11-9-4-Heap-Algorithms" class="headerlink" title="11.9.4 Heap Algorithms"></a>11.9.4 Heap Algorithms</h4><h3 id="11-10-Sorted-Range-Algorithms"><a href="#11-10-Sorted-Range-Algorithms" class="headerlink" title="11.10 Sorted-Range Algorithms"></a>11.10 Sorted-Range Algorithms</h3><h4 id="11-10-1-Searching-Elements"><a href="#11-10-1-Searching-Elements" class="headerlink" title="11.10.1 Searching Elements"></a>11.10.1 Searching Elements</h4><h4 id="11-10-2-Merging-Elements"><a href="#11-10-2-Merging-Elements" class="headerlink" title="11.10.2 Merging Elements"></a>11.10.2 Merging Elements</h4><h3 id="11-11-Numeric-Algorithms"><a href="#11-11-Numeric-Algorithms" class="headerlink" title="11.11 Numeric Algorithms"></a>11.11 Numeric Algorithms</h3><h4 id="11-11-1-Processing-Results"><a href="#11-11-1-Processing-Results" class="headerlink" title="11.11.1 Processing Results"></a>11.11.1 Processing Results</h4><h4 id="11-11-2-Converting-Relative-and-Absolute-Values"><a href="#11-11-2-Converting-Relative-and-Absolute-Values" class="headerlink" title="11.11.2 Converting Relative and Absolute Values"></a>11.11.2 Converting Relative and Absolute Values</h4><h2 id="Chapter-12-Special-Containers"><a href="#Chapter-12-Special-Containers" class="headerlink" title="Chapter 12 Special Containers"></a>Chapter 12 Special Containers</h2><p>container adapters, which adapt standard STL containers to fit special needs,<br>or a bitset, which is a containers for bits or Boolean values</p>
<h3 id="12-1-Stacks"><a href="#12-1-Stacks" class="headerlink" title="12.1 Stacks"></a>12.1 Stacks</h3><p>std::stack&lt;int,std::vector<int>&gt; st; // integer stack that uses a vector</int></p>
<h4 id="12-1-1-The-Core-Interface"><a href="#12-1-1-The-Core-Interface" class="headerlink" title="12.1.1 The Core Interface"></a>12.1.1 The Core Interface</h4><h4 id="12-1-2-Example-of-Using-Stacks"><a href="#12-1-2-Example-of-Using-Stacks" class="headerlink" title="12.1.2 Example of Using Stacks"></a>12.1.2 Example of Using Stacks</h4><p>Note that pop() removes the next element but does not return it, whereas top() returns the next element without removing it</p>
<h4 id="12-1-3-A-User-Defined-Stack-Class"><a href="#12-1-3-A-User-Defined-Stack-Class" class="headerlink" title="12.1.3 A User-Defined Stack Class"></a>12.1.3 A User-Defined Stack Class</h4><p><a href="https://github.com/israel-Liu/fragments-of-time/blob/master/boruto/codeforces/basic_data_structures.h" target="_blank" rel="noopener">Stack</a></p>
<h4 id="12-1-4-Class-stack-lt-gt-in-Detail"><a href="#12-1-4-Class-stack-lt-gt-in-Detail" class="headerlink" title="12.1.4 Class stack&lt;&gt; in Detail"></a>12.1.4 Class stack&lt;&gt; in Detail</h4><h3 id="12-2-Queues"><a href="#12-2-Queues" class="headerlink" title="12.2 Queues"></a>12.2 Queues</h3><p>容器适配器是把底层实现用容器吗。这样容器就有特殊功能。</p>
<h4 id="12-2-1-The-Core-Interface"><a href="#12-2-1-The-Core-Interface" class="headerlink" title="12.2.1 The Core Interface"></a>12.2.1 The Core Interface</h4><h4 id="12-2-3-A-User-Defined-Queue-Class"><a href="#12-2-3-A-User-Defined-Queue-Class" class="headerlink" title="12.2.3 A User-Defined Queue Class"></a>12.2.3 A User-Defined Queue Class</h4><h4 id="12-2-4-Class-queue-lt-gt-in-Detail"><a href="#12-2-4-Class-queue-lt-gt-in-Detail" class="headerlink" title="12.2.4 Class queue&lt;&gt; in Detail"></a>12.2.4 Class queue&lt;&gt; in Detail</h4><h3 id="12-3-Priority-Queues"><a href="#12-3-Priority-Queues" class="headerlink" title="12.3 Priority Queues"></a>12.3 Priority Queues</h3><p>std::priority_queue&lt;float,std::vector<float>, std::greater<float>&gt; pbuffer;</float></float></p>
<h4 id="12-3-1-The-Core-Interface"><a href="#12-3-1-The-Core-Interface" class="headerlink" title="12.3.1 The Core Interface"></a>12.3.1 The Core Interface</h4><h4 id="12-3-2-Example-of-Using-Priority-Queues"><a href="#12-3-2-Example-of-Using-Priority-Queues" class="headerlink" title="12.3.2 Example of Using Priority Queues"></a>12.3.2 Example of Using Priority Queues</h4><h4 id="12-3-3-Class-priority-queue-lt-gt-in-Detail"><a href="#12-3-3-Class-priority-queue-lt-gt-in-Detail" class="headerlink" title="12.3.3 Class priority_queue&lt;&gt; in Detail"></a>12.3.3 Class priority_queue&lt;&gt; in Detail</h4><h4 id="12-4-Container-Adapters-in-Detail"><a href="#12-4-Container-Adapters-in-Detail" class="headerlink" title="12.4 Container Adapters in Detail"></a>12.4 Container Adapters in Detail</h4><h4 id="12-4-1-Type-Definitions"><a href="#12-4-1-Type-Definitions" class="headerlink" title="12.4.1 Type Definitions"></a>12.4.1 Type Definitions</h4><h4 id="12-4-2-Constructors"><a href="#12-4-2-Constructors" class="headerlink" title="12.4.2 Constructors"></a>12.4.2 Constructors</h4><h4 id="12-4-3-Supplementary-Constructors-for-Priority-Queues"><a href="#12-4-3-Supplementary-Constructors-for-Priority-Queues" class="headerlink" title="12.4.3 Supplementary Constructors for Priority Queues"></a>12.4.3 Supplementary Constructors for Priority Queues</h4><h4 id="12-4-4-Operations"><a href="#12-4-4-Operations" class="headerlink" title="12.4.4 Operations"></a>12.4.4 Operations</h4><h3 id="12-5-Bitsets"><a href="#12-5-Bitsets" class="headerlink" title="12.5 Bitsets"></a>12.5 Bitsets</h3><h4 id="12-5-1-Examples-of-Using-Bitsets"><a href="#12-5-1-Examples-of-Using-Bitsets" class="headerlink" title="12.5.1 Examples of Using Bitsets"></a>12.5.1 Examples of Using Bitsets</h4><h4 id="12-5-2-Class-bitset-in-Detail"><a href="#12-5-2-Class-bitset-in-Detail" class="headerlink" title="12.5.2 Class bitset in Detail"></a>12.5.2 Class bitset in Detail</h4><h2 id="Chapter-13-Strings"><a href="#Chapter-13-Strings" class="headerlink" title="Chapter 13 Strings"></a>Chapter 13 Strings</h2><p>C++11提供 ’\0‘ 作为结尾 s.data() returns the characters including a trailing end-of-string character。不在提供Reference-counted。</p>
<h3 id="13-1-Purpose-of-the-String-Classes"><a href="#13-1-Purpose-of-the-String-Classes" class="headerlink" title="13.1 Purpose of the String Classes"></a>13.1 Purpose of the String Classes</h3><h4 id="13-1-1-A-First-Example-Extracting-a-Temporary-Filename"><a href="#13-1-1-A-First-Example-Extracting-a-Temporary-Filename" class="headerlink" title="13.1.1 A First Example: Extracting a Temporary Filename"></a>13.1.1 A First Example: Extracting a Temporary Filename</h4><h4 id="13-1-2-A-Second-Example-Extracting-Words-and-Printing-Them-Backward"><a href="#13-1-2-A-Second-Example-Extracting-Words-and-Printing-Them-Backward" class="headerlink" title="13.1.2 A Second Example: Extracting Words and Printing Them Backward"></a>13.1.2 A Second Example: Extracting Words and Printing Them Backward</h4><h3 id="13-2-Description-of-the-String-Classes"><a href="#13-2-Description-of-the-String-Classes" class="headerlink" title="13.2 Description of the String Classes"></a>13.2 Description of the String Classes</h3><h4 id="13-2-1-String-Types"><a href="#13-2-1-String-Types" class="headerlink" title="13.2.1 String Types"></a>13.2.1 String Types</h4><h4 id="13-2-2-Operation-Overview"><a href="#13-2-2-Operation-Overview" class="headerlink" title="13.2.2 Operation Overview"></a>13.2.2 Operation Overview</h4><h4 id="13-2-3-Constructors-and-Destructor"><a href="#13-2-3-Constructors-and-Destructor" class="headerlink" title="13.2.3 Constructors and Destructor"></a>13.2.3 Constructors and Destructor</h4><h4 id="13-2-4-Strings-and-C-Strings"><a href="#13-2-4-Strings-and-C-Strings" class="headerlink" title="13.2.4 Strings and C-Strings"></a>13.2.4 Strings and C-Strings</h4><p>const char* 可以用来构造string对象，string对象成员 data(C++11) 和 c_str 返回 ‘\0’ 结尾的 C-Strings。</p>
<pre><code>char buffer[100];
s.copy(buffer,100); // copy at most 100 characters of s into buffer
s.copy(buffer,100,2); // copy at most 100 characters of s into buffer
// starting with the third character of s
</code></pre><h4 id="13-2-5-Size-and-Capacity"><a href="#13-2-5-Size-and-Capacity" class="headerlink" title="13.2.5 Size and Capacity"></a>13.2.5 Size and Capacity</h4><h4 id="13-2-6-Element-Access"><a href="#13-2-6-Element-Access" class="headerlink" title="13.2.6 Element Access"></a>13.2.6 Element Access</h4><h4 id="13-2-7-Comparisons"><a href="#13-2-7-Comparisons" class="headerlink" title="13.2.7 Comparisons"></a>13.2.7 Comparisons</h4><h4 id="13-2-8-Modifiers"><a href="#13-2-8-Modifiers" class="headerlink" title="13.2.8 Modifiers"></a>13.2.8 Modifiers</h4><pre><code>s = &quot;&quot;; // assign the empty string
s.clear(); // clear contents //erase(begin(), end()). capacity 保持不变，
s.erase(); // erase all characters  // reserve 函数用来改变大小
</code></pre><h4 id="13-2-9-Substrings-and-String-Concatenation"><a href="#13-2-9-Substrings-and-String-Concatenation" class="headerlink" title="13.2.9 Substrings and String Concatenation"></a>13.2.9 Substrings and String Concatenation</h4><h4 id="13-2-10-Input-Output-Operators"><a href="#13-2-10-Input-Output-Operators" class="headerlink" title="13.2.10 Input/Output Operators"></a>13.2.10 Input/Output Operators</h4><p>使用getline()可以自定义结束符号。</p>
<h4 id="13-2-11-Searching-and-Finding"><a href="#13-2-11-Searching-and-Finding" class="headerlink" title="13.2.11 Searching and Finding"></a>13.2.11 Searching and Finding</h4><h4 id="13-2-12-The-Value-npos"><a href="#13-2-12-The-Value-npos" class="headerlink" title="13.2.12 The Value npos"></a>13.2.12 The Value npos</h4><p>尽量返回值直接比较，使用 size_type 不会出错。<br>    const int NPOS = -1;<br>    if (idx == NPOS) { // works almost always<br>        …<br>    }</p>
<h5 id="13-2-13-Numeric-Conversions"><a href="#13-2-13-Numeric-Conversions" class="headerlink" title="13.2.13 Numeric Conversions"></a>13.2.13 Numeric Conversions</h5><h4 id="13-2-14-Iterator-Support-for-Strings"><a href="#13-2-14-Iterator-Support-for-Strings" class="headerlink" title="13.2.14 Iterator Support for Strings"></a>13.2.14 Iterator Support for Strings</h4><h4 id="13-2-15-Internationalization"><a href="#13-2-15-Internationalization" class="headerlink" title="13.2.15 Internationalization"></a>13.2.15 Internationalization</h4><p>通过struct ignorecase_traits : public std::char_traits<char>自定义string。</char></p>
<h4 id="13-2-16-Performance"><a href="#13-2-16-Performance" class="headerlink" title="13.2.16 Performance"></a>13.2.16 Performance</h4><h4 id="13-2-17-Strings-and-Vectors"><a href="#13-2-17-Strings-and-Vectors" class="headerlink" title="13.2.17 Strings and Vectors"></a>13.2.17 Strings and Vectors</h4><p>String作为整体使用，Vector主要对里面的元素进行操作。</p>
<h3 id="13-3-String-Class-in-Detail"><a href="#13-3-String-Class-in-Detail" class="headerlink" title="13.3 String Class in Detail"></a>13.3 String Class in Detail</h3><h4 id="13-3-1-Type-Definitions-and-Static-Values"><a href="#13-3-1-Type-Definitions-and-Static-Values" class="headerlink" title="13.3.1 Type Definitions and Static Values"></a>13.3.1 Type Definitions and Static Values</h4><pre><code>string::reverse_iterator
    • The type of reverse iterators.
    • It is equivalent to reverse_iterator&lt;iterator&gt;.
string::const_reverse_iterator
    • The type of constant reverse iterators.
    • It is equivalent to reverse_iterator&lt;const_iterator&gt;.
</code></pre><h4 id="13-3-2-Create-Copy-and-Destroy-Operations"><a href="#13-3-2-Create-Copy-and-Destroy-Operations" class="headerlink" title="13.3.2 Create, Copy, and Destroy Operations"></a>13.3.2 Create, Copy, and Destroy Operations</h4><p>string::string (InputIterator beg, InputIterator end) 写重复了。</p>
<h4 id="13-3-3-Operations-for-Size-and-Capacity"><a href="#13-3-3-Operations-for-Size-and-Capacity" class="headerlink" title="13.3.3 Operations for Size and Capacity"></a>13.3.3 Operations for Size and Capacity</h4><h4 id="13-3-4-Comparisons"><a href="#13-3-4-Comparisons" class="headerlink" title="13.3.4 Comparisons"></a>13.3.4 Comparisons</h4><h4 id="13-3-5-Character-Access"><a href="#13-3-5-Character-Access" class="headerlink" title="13.3.5 Character Access"></a>13.3.5 Character Access</h4><p>Before C++11, length() or size() was an invalid index value for nonconstant strings. length() as value is invalid for at(); operator [ ], which is faster.</p>
<h4 id="13-3-6-Generating-C-Strings-and-Character-Arrays"><a href="#13-3-6-Generating-C-Strings-and-Character-Arrays" class="headerlink" title="13.3.6 Generating C-Strings and Character Arrays"></a>13.3.6 Generating C-Strings and Character Arrays</h4><p>Before C++11, the return value of data() without any trailing ’\0’ character. use c_str(); copy() 不包括结尾 \0;</p>
<h4 id="13-3-7-Modifying-Operations"><a href="#13-3-7-Modifying-Operations" class="headerlink" title="13.3.7 Modifying Operations"></a>13.3.7 Modifying Operations</h4><p>swap() 比 copy() 更快，下面函数第一个参数有歧义对于 0 .</p>
<pre><code>string&amp; string::insert (size_type idx, size_type num, char c)
iterator string::insert (const_iterator pos, size_type num, char c)
</code></pre><h4 id="13-3-8-Searching-and-Finding"><a href="#13-3-8-Searching-and-Finding" class="headerlink" title="13.3.8 Searching and Finding"></a>13.3.8 Searching and Finding</h4><p>反向找的函数起点参数用来定义区间的 [pos, end) 在这个区间内从后往前查找。]</p>
<h4 id="13-3-9-Substrings-and-String-Concatenation"><a href="#13-3-9-Substrings-and-String-Concatenation" class="headerlink" title="13.3.9 Substrings and String Concatenation"></a>13.3.9 Substrings and String Concatenation</h4><h4 id="13-3-10-Input-Output-Functions"><a href="#13-3-10-Input-Output-Functions" class="headerlink" title="13.3.10 Input/Output Functions"></a>13.3.10 Input/Output Functions</h4><h4 id="13-3-11-Numeric-Conversions"><a href="#13-3-11-Numeric-Conversions" class="headerlink" title="13.3.11 Numeric Conversions"></a>13.3.11 Numeric Conversions</h4><p>If idxRet!=nullptr, it returns the index of the first character not processed for the conversion.</p>
<h4 id="13-3-12-Generating-Iterators"><a href="#13-3-12-Generating-Iterators" class="headerlink" title="13.3.12 Generating Iterators"></a>13.3.12 Generating Iterators</h4><h4 id="13-3-13-Allocator-Support"><a href="#13-3-13-Allocator-Support" class="headerlink" title="13.3.13 Allocator Support"></a>13.3.13 Allocator Support</h4><h2 id="Chapter-14-Regular-Expressions"><a href="#Chapter-14-Regular-Expressions" class="headerlink" title="Chapter 14 Regular Expressions"></a>Chapter 14 Regular Expressions</h2>
    </div>

    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">theForger</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2019/03/24/Algorithm-Design-and-Applications/" class="pre-post btn btn-default" title='Algorithm Design and Applications'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">Algorithm Design and Applications</span>
        </a>
    
    
        <a href="/2018/12/27/2018-year-end-summary/" class="next-post btn btn-default" title='2018-year-end-summary'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">2018-year-end-summary</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
  <script id="dsq-count-scr" src="https://israel-liu.disqus.com/count.js" async></script>


<script type="text/javascript">
  var disqus_config = function () {
    this.page.url = 'https://israel-liu.github.io/2019/01/23/The-Cpp-Standard-Library-A-Tutorial-and-Reference-2nd-Edition/';
    this.page.identifier = '2019/01/23/The-Cpp-Standard-Library-A-Tutorial-and-Reference-2nd-Edition/';
    this.page.title = 'The_Cpp_Standard_Library_A_Tutorial_and_Reference_2nd_Edition';
  };
  var d = document, s = d.createElement('script');
  s.src = 'https://israel-liu.disqus.com/embed.js';
  s.setAttribute('data-timestamp', '' + +new Date());
  (d.head || d.body).appendChild(s);
</script>


	

    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Preface-to-the-Second-Edition"><span class="toc-text">Preface to the Second Edition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Acknowledgments-for-the-Second-Edition"><span class="toc-text">Acknowledgments for the Second Edition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Preface-to-the-First-Edition"><span class="toc-text">Preface to the First Edition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Acknowledgments-for-the-First-Edition"><span class="toc-text">Acknowledgments for the First Edition</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-1-About-This-Book"><span class="toc-text">Chapter 1 : About This Book</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Why-This-Book"><span class="toc-text">1.1 Why This Book</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Before-Reading-This-Book"><span class="toc-text">1.2 Before Reading This Book</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Style-and-Structure-of-the-Book"><span class="toc-text">1.3 Style and Structure of the Book</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-How-to-Read-This-Book"><span class="toc-text">1.4 How to Read This Book</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-2-Introduction-to-C-and-the-Standard-Library"><span class="toc-text">Chapter 2 Introduction to C++ and the Standard Library</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-History-of-the-C-Standards"><span class="toc-text">2.1 History of the C++ Standards</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-Common-Questions-about-the-C-11-Standard"><span class="toc-text">2.1.1 Common Questions about the C++11 Standard</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-Compatibility-between-C-98-and-C-11"><span class="toc-text">2.1.2 Compatibility between C++98 and C++11</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Complexity-and-Big-O-Notation"><span class="toc-text">2.2 Complexity and Big-O Notation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-3-New-Language-Features"><span class="toc-text">Chapter 3 : New Language Features</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-New-C-11-Language-Features"><span class="toc-text">3.1 New C++11 Language Features</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-Important-Minor-Syntax-Cleanups"><span class="toc-text">3.1.1 Important Minor Syntax Cleanups</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-Automatic-Type-Deduction-with-auto"><span class="toc-text">3.1.2 Automatic Type Deduction with auto</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-Uniform-Initialization-and-Initializer-Lists"><span class="toc-text">3.1.3 Uniform Initialization and Initializer Lists</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4-Range-Based-for-Loops"><span class="toc-text">3.1.4 Range-Based for Loops</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-5-Move-Semantics-and-Rvalue-References"><span class="toc-text">3.1.5 Move Semantics and Rvalue References</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-6-New-String-Literals"><span class="toc-text">3.1.6 New String Literals</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-7-Keyword-noexcept"><span class="toc-text">3.1.7 Keyword noexcept</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-8-Keyword-constexpr"><span class="toc-text">3.1.8 Keyword constexpr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-9-New-Template-Features"><span class="toc-text">3.1.9 New Template Features</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-10-Lambdas"><span class="toc-text">3.1.10 Lambdas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-11-Keyword-decltype"><span class="toc-text">3.1.11 Keyword decltype</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-12-New-Function-Declaration-Syntax"><span class="toc-text">3.1.12 New Function Declaration Syntax</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-13-Scoped-Enumerations"><span class="toc-text">3.1.13 Scoped Enumerations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-14-New-Fundamental-Data-Types"><span class="toc-text">3.1.14 New Fundamental Data Types</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Old-“New”-Language-Features"><span class="toc-text">3.2 Old “New” Language Features</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-Explicit-Initialization-for-Fundamental-Types"><span class="toc-text">3.2.1 Explicit Initialization for Fundamental Types</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-Definition-of-main"><span class="toc-text">3.2.2 Definition of main()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-4-General-Concepts"><span class="toc-text">Chapter 4 General Concepts</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Namespace-std"><span class="toc-text">4.1 Namespace std</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Header-Files"><span class="toc-text">4.2 Header Files</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Error-and-Exception-Handling"><span class="toc-text">4.3 Error and Exception Handling</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-Standard-Exception-Classes"><span class="toc-text">4.3.1 Standard Exception Classes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-Members-of-Exception-Classes"><span class="toc-text">4.3.2 Members of Exception Classes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-Passing-Exceptions-with-Class-exception-ptr"><span class="toc-text">4.3.3 Passing Exceptions with Class exception_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4-Throwing-Standard-Exceptions"><span class="toc-text">4.3.4 Throwing Standard Exceptions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-5-Deriving-from-Standard-Exception-Classes"><span class="toc-text">4.3.5 Deriving from Standard Exception Classes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-Callable-Objects"><span class="toc-text">4.4 Callable Objects</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-Concurrency-and-Multithreading"><span class="toc-text">4.5 Concurrency and Multithreading</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-Allocators"><span class="toc-text">4.6 Allocators</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-5-Utilities"><span class="toc-text">Chapter 5 Utilities</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Pairs-and-Tuples"><span class="toc-text">5.1 Pairs and Tuples</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-Pairs"><span class="toc-text">5.1.1 Pairs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-Tuples"><span class="toc-text">5.1.2 Tuples</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-I-O-for-Tuples"><span class="toc-text">5.1.3 I/O for Tuples</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-4-Conversions-between-tuples-and-pairs"><span class="toc-text">5.1.4 Conversions between tuples and pairs</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Smart-Pointers"><span class="toc-text">5.2 Smart Pointers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-Class-shared-ptr"><span class="toc-text">5.2.1 Class shared_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-Class-weak-ptr"><span class="toc-text">5.2.2 Class weak_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-Misusing-Shared-Pointers"><span class="toc-text">5.2.3 Misusing Shared Pointers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-4-Shared-and-Weak-Pointers-in-Detail"><span class="toc-text">5.2.4 Shared and Weak Pointers in Detail</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-5-Class-unique-ptr"><span class="toc-text">5.2.5 Class unique_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-6-Class-unique-ptr-in-Detail"><span class="toc-text">5.2.6 Class unique_ptr in Detail</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-7-Class-auto-ptr"><span class="toc-text">5.2.7 Class auto_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-8-Final-Words-on-Smart-Pointers"><span class="toc-text">5.2.8 Final Words on Smart Pointers</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Numeric-Limits"><span class="toc-text">5.3 Numeric Limits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-Type-Traits-and-Type-Utilities"><span class="toc-text">5.4 Type Traits and Type Utilities</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-Purpose-of-Type-Traits"><span class="toc-text">5.4.1 Purpose of Type Traits</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-Type-Traits-in-Detail"><span class="toc-text">5.4.2 Type Traits in Detail</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-Reference-Wrappers"><span class="toc-text">5.4.3 Reference Wrappers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-4-Function-Type-Wrappers"><span class="toc-text">5.4.4 Function Type Wrappers</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-Auxiliary-Functions"><span class="toc-text">5.5 Auxiliary Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-1-Processing-the-Minimum-and-Maximum"><span class="toc-text">5.5.1 Processing the Minimum and Maximum</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-2-Swapping-Two-Values"><span class="toc-text">5.5.2 Swapping Two Values</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-3-Supplementary-Comparison-Operators"><span class="toc-text">5.5.3 Supplementary Comparison Operators</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-Compile-Time-Fractional-Arithmetic-with-Class-ratio-lt-gt"><span class="toc-text">5.6 Compile-Time Fractional Arithmetic with Class ratio&lt;&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-Clocks-and-Timers"><span class="toc-text">5.7 Clocks and Timers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-1-Overview-of-the-Chrono-Library"><span class="toc-text">5.7.1 Overview of the Chrono Library</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-3-Clocks-and-Timepoints"><span class="toc-text">5.7.3 Clocks and Timepoints</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-4-Date-and-Time-Functions-by-C-and-POSIX"><span class="toc-text">5.7.4 Date and Time Functions by C and POSIX</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-5-Blocking-with-Timers"><span class="toc-text">5.7.5 Blocking with Timers</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-Header-Files-and"><span class="toc-text">5.8 Header Files , , and </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-2-Definitions-in"><span class="toc-text">5.8.2 Definitions in </span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-6-The-Standard-Template-Library"><span class="toc-text">Chapter 6 The Standard Template Library</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-STL-Components"><span class="toc-text">6.1 STL Components</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Containers"><span class="toc-text">6.2 Containers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-Sequence-Containers"><span class="toc-text">6.2.1 Sequence Containers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-Associative-Containers"><span class="toc-text">6.2.2 Associative Containers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-4-Associative-Arrays"><span class="toc-text">6.2.4 Associative Arrays</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-5-Other-Containers"><span class="toc-text">6.2.5 Other Containers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-6-Container-Adapters"><span class="toc-text">6.2.6 Container Adapters</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Iterators"><span class="toc-text">6.3 Iterators</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-Further-Examples-of-Using-Associative-and-Unordered-Containers"><span class="toc-text">6.3.1 Further Examples of Using Associative and Unordered Containers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-Iterator-Categories"><span class="toc-text">6.3.2 Iterator Categories</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-Algorithms"><span class="toc-text">6.4 Algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-1-Ranges"><span class="toc-text">6.4.1 Ranges</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-Handling-Multiple-Ranges"><span class="toc-text">6.4.2 Handling Multiple Ranges</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-Iterator-Adapters"><span class="toc-text">6.5 Iterator Adapters</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-1-Insert-Iterators"><span class="toc-text">6.5.1 Insert Iterators</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-2-Stream-Iterators"><span class="toc-text">6.5.2 Stream Iterators</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-3-Reverse-Iterators"><span class="toc-text">6.5.3 Reverse Iterators</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-4-Move-Iterators"><span class="toc-text">6.5.4 Move Iterators</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-User-Defined-Generic-Functions"><span class="toc-text">6.6 User-Defined Generic Functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-Manipulating-Algorithms"><span class="toc-text">6.7 Manipulating Algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-1-“Removing”-Elements"><span class="toc-text">6.7.1 “Removing” Elements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-2-Manipulating-Associative-and-Unordered-Containers"><span class="toc-text">6.7.2 Manipulating Associative and Unordered Containers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-3-Algorithms-versus-Member-Functions"><span class="toc-text">6.7.3 Algorithms versus Member Functions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-Functions-as-Algorithm-Arguments"><span class="toc-text">6.8 Functions as Algorithm Arguments</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-1-Using-Functions-as-Algorithm-Arguments"><span class="toc-text">6.8.1 Using Functions as Algorithm Arguments</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-2-Predicates"><span class="toc-text">6.8.2 Predicates</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-Using-Lambdas"><span class="toc-text">6.9 Using Lambdas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-Function-Objects"><span class="toc-text">6.10 Function Objects</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-10-1-Definition-of-Function-Objects"><span class="toc-text">6.10.1 Definition of Function Objects</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-10-2-Predefined-Function-Objects"><span class="toc-text">6.10.2 Predefined Function Objects</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-10-3-Binders"><span class="toc-text">6.10.3 Binders</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-11-Container-Elements"><span class="toc-text">6.11 Container Elements</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-11-1-Requirements-for-Container-Elements"><span class="toc-text">6.11.1 Requirements for Container Elements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-11-2-Value-Semantics-or-Reference-Semantics"><span class="toc-text">6.11.2 Value Semantics or Reference Semantics</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-12-Errors-and-Exceptions-inside-the-STL"><span class="toc-text">6.12 Errors and Exceptions inside the STL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-12-1-Error-Handling"><span class="toc-text">6.12.1 Error Handling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-12-2-Exception-Handling"><span class="toc-text">6.12.2 Exception Handling</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-13-Extending-the-STL"><span class="toc-text">6.13 Extending the STL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-13-1-Integrating-Additional-Types"><span class="toc-text">6.13.1 Integrating Additional Types</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-13-2-Deriving-from-STL-Types"><span class="toc-text">6.13.2 Deriving from STL Types</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-7-STL-Containers"><span class="toc-text">Chapter 7 STL Containers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-Common-Container-Abilities-and-Operations"><span class="toc-text">7.1 Common Container Abilities and Operations</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-1-Container-Abilities"><span class="toc-text">7.1.1 Container Abilities</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-2-Container-Operations"><span class="toc-text">7.1.2 Container Operations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-3-Container-Types"><span class="toc-text">7.1.3 Container Types</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-Arrays"><span class="toc-text">7.2 Arrays</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-Abilities-of-Arrays"><span class="toc-text">7.2.1 Abilities of Arrays</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-Array-Operations"><span class="toc-text">7.2.2 Array Operations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-Using-arrays-as-C-Style-Arrays"><span class="toc-text">7.2.3 Using arrays as C-Style Arrays</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-4-Exception-Handling"><span class="toc-text">7.2.4 Exception Handling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-5-Tuple-Interface"><span class="toc-text">7.2.5 Tuple Interface</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-6-Examples-of-Using-Arrays"><span class="toc-text">7.2.6 Examples of Using Arrays</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-Vectors"><span class="toc-text">7.3 Vectors</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1-Abilities-of-Vectors"><span class="toc-text">7.3.1 Abilities of Vectors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2-Vector-Operations"><span class="toc-text">7.3.2 Vector Operations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-3-Using-Vectors-as-C-Style-Arrays"><span class="toc-text">7.3.3 Using Vectors as C-Style Arrays</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-4-Exception-Handling"><span class="toc-text">7.3.4 Exception Handling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-5-Examples-of-Using-Vectors"><span class="toc-text">7.3.5 Examples of Using Vectors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-6-Class-vector"><span class="toc-text">7.3.6 Class vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-Deques"><span class="toc-text">7.4 Deques</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-1-Abilities-of-Deques"><span class="toc-text">7.4.1 Abilities of Deques</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-2-Deque-Operations"><span class="toc-text">7.4.2 Deque Operations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-3-Exception-Handling"><span class="toc-text">7.4.3 Exception Handling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-4-Examples-of-Using-Deques"><span class="toc-text">7.4.4 Examples of Using Deques</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-Lists"><span class="toc-text">7.5 Lists</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-1-Abilities-of-Lists"><span class="toc-text">7.5.1 Abilities of Lists</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-2-List-Operations"><span class="toc-text">7.5.2 List Operations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-3-Exception-Handling"><span class="toc-text">7.5.3 Exception Handling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-4-Examples-of-Using-Lists"><span class="toc-text">7.5.4 Examples of Using Lists</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-Forward-Lists"><span class="toc-text">7.6 Forward Lists</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-1-Abilities-of-Forward-Lists"><span class="toc-text">7.6.1 Abilities of Forward Lists</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-2-Forward-List-Operations"><span class="toc-text">7.6.2 Forward List Operations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-3-Exception-Handling"><span class="toc-text">7.6.3 Exception Handling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-4-Examples-of-Using-Forward-Lists"><span class="toc-text">7.6.4 Examples of Using Forward Lists</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-Sets-and-Multisets"><span class="toc-text">7.7 Sets and Multisets</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-1-Abilities-of-Sets-and-Multisets"><span class="toc-text">7.7.1 Abilities of Sets and Multisets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-2-Set-and-Multiset-Operations"><span class="toc-text">7.7.2 Set and Multiset Operations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-3-Exception-Handling"><span class="toc-text">7.7.3 Exception Handling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-4-Examples-of-Using-Sets-and-Multisets"><span class="toc-text">7.7.4 Examples of Using Sets and Multisets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-5-Example-of-Specifying-the-Sorting-Criterion-at-Runtime"><span class="toc-text">7.7.5 Example of Specifying the Sorting Criterion at Runtime</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-Maps-and-Multimaps"><span class="toc-text">7.8 Maps and Multimaps</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-8-1-Abilities-of-Maps-and-Multimaps"><span class="toc-text">7.8.1 Abilities of Maps and Multimaps</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-8-2-Map-and-Multimap-Operations"><span class="toc-text">7.8.2 Map and Multimap Operations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-8-3-Using-Maps-as-Associative-Arrays"><span class="toc-text">7.8.3 Using Maps as Associative Arrays</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-8-4-Exception-Handling"><span class="toc-text">7.8.4 Exception Handling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-8-5-Examples-of-Using-Maps-and-Multimaps"><span class="toc-text">7.8.5 Examples of Using Maps and Multimaps</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-8-6-Example-with-Maps-Strings-and-Sorting-Criterion-at-Runtime"><span class="toc-text">7.8.6 Example with Maps, Strings, and Sorting Criterion at Runtime</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9-Unordered-Containers"><span class="toc-text">7.9 Unordered Containers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-9-1-Abilities-of-Unordered-Containers"><span class="toc-text">7.9.1 Abilities of Unordered Containers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-9-2-Creating-and-Controlling-Unordered-Containers"><span class="toc-text">7.9.2 Creating and Controlling Unordered Containers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-9-3-Other-Operations-for-Unordered-Containers"><span class="toc-text">7.9.3 Other Operations for Unordered Containers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-9-4-The-Bucket-Interface"><span class="toc-text">7.9.4 The Bucket Interface</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-9-5-Using-Unordered-Maps-as-Associative-Arrays"><span class="toc-text">7.9.5 Using Unordered Maps as Associative Arrays</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-9-6-Exception-Handling"><span class="toc-text">7.9.6 Exception Handling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-9-7-Examples-of-Using-Unordered-Containers"><span class="toc-text">7.9.7 Examples of Using Unordered Containers</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-10-Other-STL-Containers"><span class="toc-text">7.10 Other STL Containers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-10-1-Strings-as-STL-Containers"><span class="toc-text">7.10.1 Strings as STL Containers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-10-2-Ordinary-C-Style-Arrays-as-STL-Containers"><span class="toc-text">7.10.2 Ordinary C-Style Arrays as STL Containers</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-11-Implementing-Reference-Semantics"><span class="toc-text">7.11 Implementing Reference Semantics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-12-When-to-Use-Which-Container"><span class="toc-text">7.12 When to Use Which Container</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-8-STL-Container-Members-in-Detail"><span class="toc-text">Chapter 8 STL Container Members in Detail</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-Type-Definitions"><span class="toc-text">8.1 Type Definitions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-Create-Copy-and-Destroy-Operations"><span class="toc-text">8.2 Create, Copy, and Destroy Operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-Nonmodifying-Operations"><span class="toc-text">8.3 Nonmodifying Operations</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-1-Size-Operations"><span class="toc-text">8.3.1 Size Operations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-Comparison-Operations"><span class="toc-text">8.3.2 Comparison Operations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-3-Nonmodifying-Operations-for-Associative-and-Unordered-Containers"><span class="toc-text">8.3.3 Nonmodifying Operations for Associative and Unordered Containers</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-Assignments"><span class="toc-text">8.4 Assignments</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-Direct-Element-Access"><span class="toc-text">8.5 Direct Element Access</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-Operations-to-Generate-Iterators"><span class="toc-text">8.6 Operations to Generate Iterators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-Inserting-and-Removing-Elements"><span class="toc-text">8.7 Inserting and Removing Elements</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7-1-Inserting-Single-Elements"><span class="toc-text">8.7.1 Inserting Single Elements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7-2-Inserting-Multiple-Elements"><span class="toc-text">8.7.2 Inserting Multiple Elements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7-3-Removing-Elements"><span class="toc-text">8.7.3 Removing Elements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7-4-Resizing"><span class="toc-text">8.7.4 Resizing</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-Special-Member-Functions-for-Lists-and-Forward-Lists"><span class="toc-text">8.8 Special Member Functions for Lists and Forward Lists</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-8-1-Special-Member-Functions-for-Lists-and-Forward-Lists"><span class="toc-text">8.8.1 Special Member Functions for Lists (and Forward Lists)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-8-2-Special-Member-Functions-for-Forward-Lists-Only"><span class="toc-text">8.8.2 Special Member Functions for Forward Lists Only</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-9-Container-Policy-Interfaces"><span class="toc-text">8.9 Container Policy Interfaces</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9-1-Nonmodifying-Policy-Functions"><span class="toc-text">8.9.1 Nonmodifying Policy Functions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9-2-Modifying-Policy-Functions"><span class="toc-text">8.9.2 Modifying Policy Functions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9-3-Bucket-Interface-for-Unordered-Containers"><span class="toc-text">8.9.3 Bucket Interface for Unordered Containers</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-10-Allocator-Support"><span class="toc-text">8.10 Allocator Support</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-1-Fundamental-Allocator-Members"><span class="toc-text">8.10.1 Fundamental Allocator Members</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-2-Constructors-with-Optional-Allocator-Parameters"><span class="toc-text">8.10.2 Constructors with Optional Allocator Parameters</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-9-STL-Iterators"><span class="toc-text">Chapter 9 STL Iterators</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-Header-Files-for-Iterators"><span class="toc-text">9.1 Header Files for Iterators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-Iterator-Categories"><span class="toc-text">9.2 Iterator Categories</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2-Input-Iterators"><span class="toc-text">9.2.2 Input Iterators</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-3-Forward-Iterators"><span class="toc-text">9.2.3 Forward Iterators</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-4-Bidirectional-Iterators"><span class="toc-text">9.2.4 Bidirectional Iterators</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-5-Random-Access-Iterators"><span class="toc-text">9.2.5 Random-Access Iterators</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-6-The-Increment-and-Decrement-Problem-of-Vector-Iterators"><span class="toc-text">9.2.6 The Increment and Decrement Problem of Vector Iterators</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-Auxiliary-Iterator-Functions"><span class="toc-text">9.3 Auxiliary Iterator Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-1-advance"><span class="toc-text">9.3.1 advance()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-next-and-prev"><span class="toc-text">9.3.2 next() and prev()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-3-distance"><span class="toc-text">9.3.3 distance()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-4-iter-swap"><span class="toc-text">9.3.4 iter_swap()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-Iterator-Adapters"><span class="toc-text">9.4 Iterator Adapters</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-1-Reverse-Iterators"><span class="toc-text">9.4.1 Reverse Iterators</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-2-Insert-Iterators"><span class="toc-text">9.4.2 Insert Iterators</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-3-Stream-Iterators"><span class="toc-text">9.4.3 Stream Iterators</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-4-Move-Iterators"><span class="toc-text">9.4.4 Move Iterators</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-Iterator-Traits"><span class="toc-text">9.5 Iterator Traits</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-1-Writing-Generic-Functions-for-Iterators"><span class="toc-text">9.5.1 Writing Generic Functions for Iterators</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-6-Writing-User-Defined-Iterators"><span class="toc-text">9.6 Writing User-Defined Iterators</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-10-STL-Function-Objects-and-Using-Lambdas"><span class="toc-text">Chapter 10 STL Function Objects and Using Lambdas</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-The-Concept-of-Function-Objects"><span class="toc-text">10.1 The Concept of Function Objects</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-1-Function-Objects-as-Sorting-Criteria"><span class="toc-text">10.1.1 Function Objects as Sorting Criteria</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-2-Function-Objects-with-Internal-State"><span class="toc-text">10.1.2 Function Objects with Internal State</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-3-The-Return-Value-of-for-each"><span class="toc-text">10.1.3 The Return Value of for_each()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-4-Predicates-versus-Function-Objects"><span class="toc-text">10.1.4 Predicates versus Function Objects</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-Predefined-Function-Objects-and-Binders"><span class="toc-text">10.2 Predefined Function Objects and Binders</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-1-Predefined-Function-Objects"><span class="toc-text">10.2.1 Predefined Function Objects</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-2-Function-Adapters-and-Binders"><span class="toc-text">10.2.2 Function Adapters and Binders</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-3-User-Defined-Function-Objects-for-Function-Adapters"><span class="toc-text">10.2.3 User-Defined Function Objects for Function Adapters</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-4-Deprecated-Function-Adapters"><span class="toc-text">10.2.4 Deprecated Function Adapters</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-Using-Lambdas"><span class="toc-text">10.3 Using Lambdas</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-1-Lambdas-versus-Binders"><span class="toc-text">10.3.1 Lambdas versus Binders</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-2-Lambdas-versus-Stateful-Function-Objects"><span class="toc-text">10.3.2 Lambdas versus Stateful Function Objects</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-3-Lambdas-Calling-Global-and-Member-Functions"><span class="toc-text">10.3.3 Lambdas Calling Global and Member Functions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-4-Lambdas-as-Hash-Function-Sorting-or-Equivalence-Criterion"><span class="toc-text">10.3.4 Lambdas as Hash Function, Sorting, or Equivalence Criterion</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-11-STL-Algorithms"><span class="toc-text">Chapter 11 STL Algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-Algorithm-Header-Files"><span class="toc-text">11.1 Algorithm Header Files</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-Algorithm-Overview"><span class="toc-text">11.2 Algorithm Overview</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-1-A-Brief-Introduction"><span class="toc-text">11.2.1 A Brief Introduction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-2-Classification-of-Algorithms"><span class="toc-text">11.2.2 Classification of Algorithms</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-Auxiliary-Functions"><span class="toc-text">11.3 Auxiliary Functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-The-for-each-Algorithm"><span class="toc-text">11.4 The for_each() Algorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-Nonmodifying-Algorithms"><span class="toc-text">11.5 Nonmodifying Algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-5-1-Counting-Elements"><span class="toc-text">11.5.1 Counting Elements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-5-2-Minimum-and-Maximum"><span class="toc-text">11.5.2 Minimum and Maximum</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-5-3-Searching-Elements"><span class="toc-text">11.5.3 Searching Elements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-5-4-Comparing-Ranges"><span class="toc-text">11.5.4 Comparing Ranges</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-5-5-Predicates-for-Ranges"><span class="toc-text">11.5.5 Predicates for Ranges</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6-Modifying-Algorithms"><span class="toc-text">11.6 Modifying Algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-1-Copying-Elements"><span class="toc-text">11.6.1 Copying Elements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-2-Moving-Elements"><span class="toc-text">11.6.2 Moving Elements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-3-Transforming-and-Combining-Elements"><span class="toc-text">11.6.3 Transforming and Combining Elements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-4-Swapping-Elements"><span class="toc-text">11.6.4 Swapping Elements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-5-Assigning-New-Values"><span class="toc-text">11.6.5 Assigning New Values</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-6-Replacing-Elements"><span class="toc-text">11.6.6 Replacing Elements</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-7-Removing-Algorithms"><span class="toc-text">11.7 Removing Algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-7-1-Removing-Certain-Values"><span class="toc-text">11.7.1 Removing Certain Values</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-7-2-Removing-Duplicates"><span class="toc-text">11.7.2 Removing Duplicates</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-8-Mutating-Algorithms"><span class="toc-text">11.8 Mutating Algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-8-1-Reversing-the-Order-of-Elements"><span class="toc-text">11.8.1 Reversing the Order of Elements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-8-2-Rotating-Elements"><span class="toc-text">11.8.2 Rotating Elements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-8-3-Permuting-Elements"><span class="toc-text">11.8.3 Permuting Elements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-8-4-Shuffling-Elements"><span class="toc-text">11.8.4 Shuffling Elements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-8-5-Moving-Elements-to-the-Front"><span class="toc-text">11.8.5 Moving Elements to the Front</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-8-6-Partition-into-Two-Subranges"><span class="toc-text">11.8.6 Partition into Two Subranges</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-9-Sorting-Algorithms"><span class="toc-text">11.9 Sorting Algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-9-1-Sorting-All-Elements"><span class="toc-text">11.9.1 Sorting All Elements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-9-2-Partial-Sorting"><span class="toc-text">11.9.2 Partial Sorting</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-9-3-Sorting-According-to-the-nth-Element"><span class="toc-text">11.9.3 Sorting According to the nth Element</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-9-4-Heap-Algorithms"><span class="toc-text">11.9.4 Heap Algorithms</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-10-Sorted-Range-Algorithms"><span class="toc-text">11.10 Sorted-Range Algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-10-1-Searching-Elements"><span class="toc-text">11.10.1 Searching Elements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-10-2-Merging-Elements"><span class="toc-text">11.10.2 Merging Elements</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-11-Numeric-Algorithms"><span class="toc-text">11.11 Numeric Algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-11-1-Processing-Results"><span class="toc-text">11.11.1 Processing Results</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-11-2-Converting-Relative-and-Absolute-Values"><span class="toc-text">11.11.2 Converting Relative and Absolute Values</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-12-Special-Containers"><span class="toc-text">Chapter 12 Special Containers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-Stacks"><span class="toc-text">12.1 Stacks</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-1-The-Core-Interface"><span class="toc-text">12.1.1 The Core Interface</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-2-Example-of-Using-Stacks"><span class="toc-text">12.1.2 Example of Using Stacks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-3-A-User-Defined-Stack-Class"><span class="toc-text">12.1.3 A User-Defined Stack Class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-4-Class-stack-lt-gt-in-Detail"><span class="toc-text">12.1.4 Class stack&lt;&gt; in Detail</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-Queues"><span class="toc-text">12.2 Queues</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-1-The-Core-Interface"><span class="toc-text">12.2.1 The Core Interface</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-3-A-User-Defined-Queue-Class"><span class="toc-text">12.2.3 A User-Defined Queue Class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-4-Class-queue-lt-gt-in-Detail"><span class="toc-text">12.2.4 Class queue&lt;&gt; in Detail</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-Priority-Queues"><span class="toc-text">12.3 Priority Queues</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-1-The-Core-Interface"><span class="toc-text">12.3.1 The Core Interface</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-2-Example-of-Using-Priority-Queues"><span class="toc-text">12.3.2 Example of Using Priority Queues</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-3-Class-priority-queue-lt-gt-in-Detail"><span class="toc-text">12.3.3 Class priority_queue&lt;&gt; in Detail</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-Container-Adapters-in-Detail"><span class="toc-text">12.4 Container Adapters in Detail</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-1-Type-Definitions"><span class="toc-text">12.4.1 Type Definitions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-2-Constructors"><span class="toc-text">12.4.2 Constructors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-3-Supplementary-Constructors-for-Priority-Queues"><span class="toc-text">12.4.3 Supplementary Constructors for Priority Queues</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-4-Operations"><span class="toc-text">12.4.4 Operations</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-Bitsets"><span class="toc-text">12.5 Bitsets</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-5-1-Examples-of-Using-Bitsets"><span class="toc-text">12.5.1 Examples of Using Bitsets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-5-2-Class-bitset-in-Detail"><span class="toc-text">12.5.2 Class bitset in Detail</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-13-Strings"><span class="toc-text">Chapter 13 Strings</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-Purpose-of-the-String-Classes"><span class="toc-text">13.1 Purpose of the String Classes</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-1-A-First-Example-Extracting-a-Temporary-Filename"><span class="toc-text">13.1.1 A First Example: Extracting a Temporary Filename</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-2-A-Second-Example-Extracting-Words-and-Printing-Them-Backward"><span class="toc-text">13.1.2 A Second Example: Extracting Words and Printing Them Backward</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-Description-of-the-String-Classes"><span class="toc-text">13.2 Description of the String Classes</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-1-String-Types"><span class="toc-text">13.2.1 String Types</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-2-Operation-Overview"><span class="toc-text">13.2.2 Operation Overview</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-3-Constructors-and-Destructor"><span class="toc-text">13.2.3 Constructors and Destructor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-4-Strings-and-C-Strings"><span class="toc-text">13.2.4 Strings and C-Strings</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-5-Size-and-Capacity"><span class="toc-text">13.2.5 Size and Capacity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-6-Element-Access"><span class="toc-text">13.2.6 Element Access</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-7-Comparisons"><span class="toc-text">13.2.7 Comparisons</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-8-Modifiers"><span class="toc-text">13.2.8 Modifiers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-9-Substrings-and-String-Concatenation"><span class="toc-text">13.2.9 Substrings and String Concatenation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-10-Input-Output-Operators"><span class="toc-text">13.2.10 Input/Output Operators</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-11-Searching-and-Finding"><span class="toc-text">13.2.11 Searching and Finding</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-12-The-Value-npos"><span class="toc-text">13.2.12 The Value npos</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#13-2-13-Numeric-Conversions"><span class="toc-text">13.2.13 Numeric Conversions</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-14-Iterator-Support-for-Strings"><span class="toc-text">13.2.14 Iterator Support for Strings</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-15-Internationalization"><span class="toc-text">13.2.15 Internationalization</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-16-Performance"><span class="toc-text">13.2.16 Performance</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-17-Strings-and-Vectors"><span class="toc-text">13.2.17 Strings and Vectors</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-String-Class-in-Detail"><span class="toc-text">13.3 String Class in Detail</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-1-Type-Definitions-and-Static-Values"><span class="toc-text">13.3.1 Type Definitions and Static Values</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-2-Create-Copy-and-Destroy-Operations"><span class="toc-text">13.3.2 Create, Copy, and Destroy Operations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-3-Operations-for-Size-and-Capacity"><span class="toc-text">13.3.3 Operations for Size and Capacity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-4-Comparisons"><span class="toc-text">13.3.4 Comparisons</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-5-Character-Access"><span class="toc-text">13.3.5 Character Access</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-6-Generating-C-Strings-and-Character-Arrays"><span class="toc-text">13.3.6 Generating C-Strings and Character Arrays</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-7-Modifying-Operations"><span class="toc-text">13.3.7 Modifying Operations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-8-Searching-and-Finding"><span class="toc-text">13.3.8 Searching and Finding</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-9-Substrings-and-String-Concatenation"><span class="toc-text">13.3.9 Substrings and String Concatenation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-10-Input-Output-Functions"><span class="toc-text">13.3.10 Input/Output Functions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-11-Numeric-Conversions"><span class="toc-text">13.3.11 Numeric Conversions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-12-Generating-Iterators"><span class="toc-text">13.3.12 Generating Iterators</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-13-Allocator-Support"><span class="toc-text">13.3.13 Allocator Support</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-14-Regular-Expressions"><span class="toc-text">Chapter 14 Regular Expressions</span></a></li></ol>
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<!--<a id="toc-btn">
    <i class="fa fa-bars"></i>
</a>-->

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12"> 
                <span>Copyright &copy; 2017
                </span> | 
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> | 
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>



	<script src="/js/search.js?rev=@@hash"></script>


<script src="/js/app.js?rev=@@hash"></script>


</body>
</html>